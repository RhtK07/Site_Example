
  <head>
    <title>An overview of proxy-label approaches for semi-supervised learning</title>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">



<link rel="apple-touch-icon" sizes="57x57" href="../assets/img/apple-touch-icon-57x57.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="60x60" href="../assets/img/apple-touch-icon-60x60.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="72x72" href="../assets/img/apple-touch-icon-72x72.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="76x76" href="../assets/img/apple-touch-icon-76x76.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="114x114" href="../assets/img/apple-touch-icon-114x114.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="120x120" href="../assets/img/apple-touch-icon-120x120.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="144x144" href="../assets/img/apple-touch-icon-144x144.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="152x152" href="../assets/img/apple-touch-icon-152x152.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="180x180" href="../assets/img/apple-touch-icon-180x180.png?v=wAAv6Wqe6l">
<link rel="icon" type="image/png" href="../assets/img/favicon-32x32.png?v=wAAv6Wqe6l" sizes="32x32">
<link rel="icon" type="image/png" href="../assets/img/favicon-194x194.png?v=wAAv6Wqe6l" sizes="194x194">
<link rel="icon" type="image/png" href="../assets/img/favicon-96x96.png?v=wAAv6Wqe6l" sizes="96x96">
<link rel="icon" type="image/png" href="../assets/img/android-chrome-192x192.png?v=wAAv6Wqe6l" sizes="192x192">
<link rel="icon" type="image/png" href="../assets/img/favicon-16x16.png?v=wAAv6Wqe6l" sizes="16x16">
<link rel="manifest" href="../assets/img/manifest.json?v=wAAv6Wqe6l">
<link rel="shortcut icon" href="../assets/img/favicon.ico?v=wAAv6Wqe6l">
<meta name="msapplication-TileColor" content="#e74c3c">
<meta name="msapplication-TileImage" content="/assets/img/mstile-144x144.png?v=wAAv6Wqe6l">
<meta name="msapplication-config" content="/assets/img/browserconfig.xml?v=wAAv6Wqe6l">
<meta name="theme-color" content="#e74c3c">
    <link rel="stylesheet" type="text/css" href="../assets/css/uno-zen.css?v=048ab6045a">
    <link rel="canonical" href="http://ruder.io/semi-supervised/">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="Sebastian Ruder">
    <meta property="og:type" content="article">
    <meta property="og:title" content="An overview of proxy-label approaches for semi-supervised learning">
    <meta property="og:description" content="Note: Parts of this post are based on my ACL 2018 paper Strong Baselines for Neural Semi-supervised Learning under Domain Shift with Barbara Plank. Table of contents: Self-training Multi-view training Co-training Democratic Co-learning Tri-training Tri-training with disagreement Asymmetric tri-training Multi-task...">
    <meta property="og:url" content="u=http://ruder.io/semi-supervised/">
    <meta property="article:published_time" content="2018-04-26T07:00:00.000Z">
    <meta property="article:modified_time" content="2018-08-29T16:20:22.003Z">
    <meta property="article:tag" content="deep learning">
    <meta property="article:tag" content="semi-supervised learning">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="An overview of proxy-label approaches for semi-supervised learning">
    <meta name="twitter:description" content="Note: Parts of this post are based on my ACL 2018 paper Strong Baselines for Neural Semi-supervised Learning under Domain Shift with Barbara Plank. Table of contents: Self-training Multi-view training Co-training Democratic Co-learning Tri-training Tri-training with disagreement Asymmetric tri-training Multi-task...">
    <meta name="twitter:url" content="u=http://ruder.io/semi-supervised/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Sebastian Ruder",
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "url": "u=http://ruder.io/author/sebastian",
        "sameAs": null,
        "description": null
    },
    "headline": "An overview of proxy-label approaches for semi-supervised learning",
    "url": "u=http://ruder.io/semi-supervised/",
    "datePublished": "2018-04-26T07:00:00.000Z",
    "dateModified": "2018-08-29T16:20:22.003Z",
    "keywords": "deep learning, semi-supervised learning",
    "description": "Note: Parts of this post are based on my ACL 2018 paper Strong Baselines for Neural Semi-supervised Learning under Domain Shift with Barbara Plank. Table of contents: Self-training Multi-view training Co-training Democratic Co-learning Tri-training Tri-training with disagreement Asymmetric tri-training Multi-task..."
}
    </script>

    <meta name="generator" content="Ghost 0.7">
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="http://ruder.io/rss/">
    <script>
var open_button = '.nav-blog > a'
</script>
<script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
  </head>
  <body class="post-template tag-deep-learning tag-semi-supervised-learning">
    <header id="menu-button" class="expanded">
      <a><i class="icon icon-list"></i></a>
    </header>
    <aside class="cover" style="background: url(../content/images/2017/05/imageedit_8_8459453433.jpg) center/cover no-repeat fixed">
  <div class="cover container">
    <div class="profile">
      <a id="avatar-link" title="link to homepage for Sebastian Ruder" href="http://ruder.io/#open">
        <img src="../content/images/2015/12/Seb_LinkedIn_Profile-.png" alt="Sebastian Ruder avatar" class="profile avatar rounded hvr-buzz-out">
        <h1 id="profile-title">Sebastian Ruder</h1>
        <h3 id="profile-resume"></h3>
      </a>

      <hr class="divider long">
      <p>I'm a PhD student in Natural Language Processing and a research scientist at AYLIEN. I blog about Machine Learning, Deep Learning, NLP, and startups.</p>
      <hr class="divider short">
      <div class="navigation">
        <div class="profile contact">
          <nav class="navigation left">
  <ul class="links">
      <li class="nav-blog ">
        <a href="http://ruder.io/">Blog</a>
      </li>
      <li class="nav-about ">
        <a href="http://ruder.io/about/">About</a>
      </li>
      <li class="nav-papers ">
        <a href="http://ruder.io/publications/">Papers</a>
      </li>
      <li class="nav-news ">
        <a href="http://ruder.io/news">News</a>
      </li>
      <li class="nav-newsletter ">
        <a href="http://newsletter.ruder.io">Newsletter</a>
      </li>
      <li class="nav-faq ">
        <a href="http://ruder.io/faq">FAQ</a>
      </li>
      <li class="nav-progress ">
        <a href="https://nlpprogress.com/">Progress</a>
      </li>
  </ul>
</nav>

          
<nav class="navigation right">
  <ul class="social expanded">

  <!-- Twitter -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="http://twitter.com/seb_ruder" title="@seb_ruder on Twitter">
      <i class="icon icon-social-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  <!-- Linkedin -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://www.linkedin.com/in/sebastianruder" title="sebastianruder on LinkedIn">
      <i class="icon icon-social-linkedin"></i>
      <span class="label">Linkedin</span>
    </a>
  </li>

  <!-- Github -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://github.com/sebastianruder" title="sebastianruder on Github">
      <i class="icon icon-social-github"></i>
      <span class="label">Github</span>
    </a>
  </li>

  <!-- E-mail -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="mailto:sebastian@ruder.io" title="send me an email">
      <i class="icon icon-mail"></i>
      <span class="label">Email</span>
    </a>
  </li>

  <!-- RSS -->
  <li class="social item hvr-grow-rotate">
    <a href="../rss/index.rss" title="Subscribe to RSS">
      <i class="icon icon-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>

  </ul>
</nav>
          <section class="icon icon-search" id="search-container">
  <hr class="divider short">
  <form id="search-form" action="https://www.google.com/#q=site:u=http://ruder.io">
    <input type="text" name="search" placeholder="Deep Learning, NLP, ..." id="search-field">
  </form>
</section>
        </div>
      </div>
    </div>
  </div>
</aside>
    <main>
      <section id="search-results"></section>
      <section class="content">
        

  <article class="post tag-deep-learning tag-semi-supervised-learning">
    <header>
      <div class="post meta">
        <time datetime="26 Apr 2018">26 Apr 2018</time>
        <span class="post tags">in <a href="../tag/deep-learning/">deep learning</a> <a href="../tag/semi-supervised-learning/">semi-supervised learning</a></span>


        <span class="post reading-time"> ~ <span></span> read.</span>
      </div>
      <a alt="Tweet 'An overview of proxy-label approaches for semi-supervised learning'" href="https://twitter.com/intent/tweet?text=An%20overview%20of%20proxy-label%20approaches%20for%20semi-supervised%20learning%20%C2%BB&amp;hashtags=deep%20learning,semi-supervised%20learning&amp;url=http://ruder.io/semi-supervised/">
        
        <h1 class="icon-reverse icon-social-twitter-post" id="post-title">An overview of proxy-label approaches for semi-supervised learning</h1>
      </a>
    </header>

    <div id="post-content" class="post tag-deep-learning tag-semi-supervised-learning">
      <p>Note: Parts of this post are based on my ACL 2018 paper <a href="https://arxiv.org/abs/1804.09530">Strong Baselines for Neural Semi-supervised Learning under Domain Shift</a> with <a href="http://www.let.rug.nl/bplank/">Barbara Plank</a>.</p>

<p>Table of contents:</p>

<ul>
<li><a href="index.html#selftraining">Self-training</a></li>
<li><a href="index.html#multiviewtraining">Multi-view training</a>
<ul><li>Co-training</li>
<li>Democratic Co-learning</li>
<li>Tri-training</li>
<li>Tri-training with disagreement</li>
<li>Asymmetric tri-training</li>
<li>Multi-task tri-training</li></ul></li>
<li><a href="index.html#selfensembling">Self-ensembling</a>
<ul><li>Ladder networks</li>
<li>Virtual Adversarial Training</li>
<li>\(\Pi\) model</li>
<li>Temporal Ensembling</li>
<li>Mean Teacher</li></ul></li>
<li><a href="index.html#relatedmethodsandareas">Related methods and areas</a>
<ul><li>Distillation</li>
<li>Learning from weak supervision</li>
<li>Learning with noisy labels</li>
<li>Data augmentation</li>
<li>Ensembling a single model</li></ul></li>
</ul>

<p>Unsupervised learning constitutes one of the main challenges for current machine learning models and one of the key elements that is missing for <a href="http://ruder.io/highlights-nips-2016/#generalartificialintelligence">general artificial intelligence</a>. While unsupervised learning on its own is still elusive, researchers have a made a lot of progress in <em>combining</em> unsupervised learning with supervised learning. This branch of machine learning research is called semi-supervised learning.</p>

<p>Semi-supervised learning has a long history. For a (slightly outdated) overview, refer to Zhu (2005) [<sup id="fnref:1"><a href="index.html#fn:1" rel="footnote">1</a></sup>] and Chapelle et al. (2006) [<sup id="fnref:2"><a href="index.html#fn:2" rel="footnote">2</a></sup>]. Particularly recently, semi-supervised learning has seen some success, considerably reducing the error rate on important benchmarks. Semi-supervised learning also makes an appearance in <a href="https://www.sec.gov/Archives/edgar/data/1018724/000119312518121161/d456916dex991.htm">Amazon's annual letter to shareholders</a> where it is credited with reducing the amount of labelled data needed to achieve the same accuracy improvement by \(40\times\).</p>

<p>In this blog post, I will focus on a particular class of semi-supervised learning algorithms that produce <em>proxy labels</em> on unlabelled data, which are used as targets together with the labelled data. These proxy labels are produced by the model itself or variants of it without any additional supervision; they thus do not reflect the ground truth but might still provide some signal for learning. In a sense, these labels can be considered <em>noisy</em> or <em>weak</em>. I will highlight the connection to learning from noisy labels, weak supervision as well as other related topics in the end of this post.</p>

<p>This class of models is of particular interest in my opinion, as a) deep neural networks have been shown to be good at dealing with noisy labels and b) these models have achieved state-of-the-art in semi-supervised learning for computer vision. Note that many of these ideas are not new and many related methods have been developed in the past. In one half of this post, I will thus cover classic methods and discuss their relevance for current approaches; in the other half, I will discuss techniques that have recently achieved state-of-the-art performance. Some of the following approaches have been referred to as <em>self-teaching</em> or <em>bootstrapping</em> algorithms; I am not aware of a term that captures all of them, so I will simply refer to them as <em>proxy-label</em> methods.</p>

<p>I will divide these methods in three groups, which I will discuss in the following: 1) self-training, which uses a model's own predictions as proxy labels; 2) multi-view learning, which uses the predictions of models trained with different <em>views</em> of the data; and 3) self-ensembling, which ensembles variations of a model's own predictions and uses these as feedback for learning. I will show pseudo-code for the most important algorithms. You can find the LaTeX source <a href="https://github.com/sebastianruder/semi-supervised">here</a>. </p>

<p>There are many interesting and equally important directions for semi-supervised learning that I will not cover in this post, e.g. graph-convolutional neural networks [<sup id="fnref:3"><a href="index.html#fn:3" rel="footnote">3</a></sup>].</p>

<h2 id="selftraining">Self-training</h2>

<p>Self-training (Yarowsky, 1995; McClosky et al., 2006) [<sup id="fnref:4"><a href="index.html#fn:4" rel="footnote">4</a></sup>, <sup id="fnref:5"><a href="index.html#fn:5" rel="footnote">5</a></sup>] is one of the earliest and simplest approaches to semi-supervised learning and the most straightforward example of how a model's own predictions can be incorporated into training. As the name implies, self-training leverages a model's own predictions on unlabelled data in order to obtain additional information that can be used during training. Typically the most confident predictions are taken at face value, as detailed next.</p>

<p>Formally, self-training trains a model \(m\) on a labeled training set \(L\) and an unlabeled data set \(U\). At each iteration, the model provides predictions \(m(x)\) in the form of a probability distribution over the \(C\) classes for all unlabeled examples \(x\) in \(U\). If the probability assigned to the most likely class is higher than a predetermined threshold \(\tau\), \(x\) is added to the labeled examples with \(\DeclareMathOperator*{\argmax}{argmax} p(x) = \argmax m(x)\) as pseudo-label. This process is generally repeated for a fixed number of iterations or until no more predictions on unlabelled examples are confident. This instantiation is the most widely used and shown in Algorithm 1. <br>
<img src="../content/images/2018/03/self-training.png" alt="">
Classic self-training has shown mixed success. In parsing it proved successful with small datasets (Reichart, and Rappoport, 2007; Huang and Harper, 2009) [<sup id="fnref:6"><a href="index.html#fn:6" rel="footnote">6</a></sup>, <sup id="fnref:13"><a href="index.html#fn:13" rel="footnote">13</a></sup>] or when a generative component is used together with a reranker when more data is available (McClosky et al., 2006; Suzuki and Isozaki , 2008) [<sup id="fnref:7"><a href="index.html#fn:7" rel="footnote">7</a></sup>]. Some success was achieved with careful task-specific data selection (Petrov and McDonald, 2012) [<sup id="fnref:8"><a href="index.html#fn:8" rel="footnote">8</a></sup>], while others report limited success on a variety of NLP tasks (He and Zhou, 2011; Plank, 2011; Van Asch and Daelemans, 2016; van der Goot et al., 2017) [<sup id="fnref:9"><a href="index.html#fn:9" rel="footnote">9</a></sup>, <sup id="fnref:10"><a href="index.html#fn:10" rel="footnote">10</a></sup>, <sup id="fnref:11"><a href="index.html#fn:11" rel="footnote">11</a></sup>, <sup id="fnref:12"><a href="index.html#fn:12" rel="footnote">12</a></sup>].</p>

<p>The main downside of self-training is that the model is unable to correct its own mistakes. If the model's predictions on unlabelled data are confident but wrong, the erroneous data is nevertheless incorporated into training and the model's errors are amplified. This effect is exacerbated if the domain of the unlabelled data is different from that of the labelled data; in this case, the model's confidence will be a poor predictor of its performance.</p>

<h2 id="multiviewtraining"> Multi-view training</h2>

<p>Multi-view training aims to train different models with different <em>views</em> of the data. Ideally, these views complement each other and the models can collaborate in improving each other's performance. These views can differ in different ways such as in the features they use, in the architectures of the models, or in the data on which the models are trained.</p>

<p><strong>Co-training</strong>   Co-training (Blum and Mitchell, 1998) [<sup id="fnref:17"><a href="index.html#fn:17" rel="footnote">17</a></sup>] is a classic multi-view training method, which makes comparatively strong assumptions. It requires that the data \(L\) can be represented using two conditionally independent feature sets \(L^1\) and \(L^2\) and that each feature set is sufficient to train a good model. After the initial models \(m_1\) and \(m_2\) are trained on their respective feature sets, at each iteration, only inputs that are confident (i.e. have a probability higher than a threshold \(\tau\)) according to <em>exactly one</em> of the two models are moved to the training set of <em>the other</em> model. One model thus provides the labels to the inputs on which the <em>other</em> model is uncertain. Co-training can be seen in Algorithm 2.
<img src="../content/images/2018/04/co-training.png" alt="">
In the original co-training paper (Blum and Mitchell, 1998), co-training is used to classify web pages using the text on the page as one view and the anchor text of hyperlinks on other pages pointing to the page as the other view. As two conditionally independent views are not always available, Chen et al. (2011) [<sup id="fnref:19"><a href="index.html#fn:19" rel="footnote">19</a></sup>] propose pseudo-multiview regularization (Chen et al., 2011) in order to split the features into two mutually exclusive views so that co-training is effective. To this end, pseudo-multiview regularization constrains the models so that at least one of them has a zero weight for each feature. This is similar to the orthogonality constraint recently used in domain adaptation to encourage shared and private spaces (Bousmalis et al., 2016) [<sup id="fnref:20"><a href="index.html#fn:20" rel="footnote">20</a></sup>]. A second constraint requires the models to be confident on different subsets of \(U\). Chen et al. (2011) [<sup id="fnref:18"><a href="index.html#fn:18" rel="footnote">18</a></sup>] use pseudo-multiview regularization to adapt co-training to domain adaptation.</p>

<p><strong>Democratic Co-learning</strong> Rather than treating different feature sets as views, democratic co-learning (Zhou and Goldman, 2004) [<sup id="fnref:21"><a href="index.html#fn:21" rel="footnote">21</a></sup>] employs models with <em>different inductive biases</em>. These can be different network architectures in the case of neural networks or completely different learning algorithms. Democratic co-learning first trains each model separately on the complete labelled data \(L\). The models then make predictions on the unlabelled data \(U\). If a majority of models confidently agree on the label of an example, the example is added to the labelled dataset. Confidence is measured in the original formulation by measuring if the sum of the mean confidence intervals \(w\) of the models, which agreed on the label is larger than the sum of the models that disagreed. This process is repeated until no more examples are added. The final prediction is made with a majority vote weighted with the confidence intervals of the models. The full algorithm can be seen below. \(M\) is the set of all models that predict the same label \(j\) for an example \(x\). 
<img src="../content/images/2018/04/democratic_co-learning-2.png" alt="">
<strong>Tri-training</strong>   Tri-training (Zhou and Li, 2005) [<sup id="fnref:14"><a href="index.html#fn:14" rel="footnote">14</a></sup>] is one of the best known multi-view training   methods. It can be seen as an instantiation of democratic co-learning, which leverages the agreement of three independently trained models to reduce the bias of predictions on unlabeled data. The main requirement for tri-training is that the initial models are diverse. This can be achieved using different model architectures as in democratic co-learning. The most common way to obtain diversity for tri-training, however, is to obtain different variations \(S_i\) of the original training data \(L\) using bootstrap sampling. The three models \(m_1\), \(m_2\), and \(m_3\) are then trained on these bootstrap samples, as depicted in Algorithm 4. An unlabeled data point is added to the training set of a model \(m_i\) if the other two models \(m_j\) and \(m_k\) agree on its label. Training stops when the classifiers do not change anymore.
<img src="../content/images/2018/04/tri-training.png" alt="">
Despite having been proposed more than 10 years ago, before the advent of Deep Learning, we found in a <a href="https://arxiv.org/abs/1804.09530">recent paper</a> (Ruder and Plank, 2018) [<sup id="fnref:22"><a href="index.html#fn:22" rel="footnote">22</a></sup>] that classic tri-training is a strong baseline for neural semi-supervised with and without domain shift for NLP and that it outperforms even recent state-of-the-art methods.</p>

<p><strong>Tri-training with disagreement</strong>   Tri-training <em>with disagreement</em> (Søgaard, 2010) [<sup id="fnref:15"><a href="index.html#fn:15" rel="footnote">15</a></sup>] is based on the intuition that a model should only be strengthened in its weak points and that the labeled data should not be skewed by easy data points. In order to achieve this, it adds a simple modification to the original algorithm (altering line 8 in Algorithm 2), requiring that for an unlabeled data point on which \(m_j\) and \(m_k\) <em>agree</em>, the other model \(m_i\) <em>disagrees</em> on the prediction. Tri-training with disagreement is more data-efficient than tri-training and has achieved competitive results on part-of-speech tagging (Søgaard, 2010).</p>

<p><strong>Asymmetric tri-training</strong>   Asymmetic tri-training (Saito et al., 2017) [<sup id="fnref:16"><a href="index.html#fn:16" rel="footnote">16</a></sup>] is a recently proposed extension of tri-training that achieved state-of-the-art results for unsupervised domain adaptation in computer vision. For unsupervised domain adaptation, the test data and unlabeled data are from a different domain than the labelled examples. To adapt tri-training to this shift, asymmetric tri-training learns one of the models <em>only</em> on proxy labels and not on labelled examples (a change to line 10 in Algorithm 4) and uses only this model to classify target domain examples at test time. In addition, all three models share the same feature extractor.</p>

<p><strong>Multi-task tri-training</strong>   Tri-training typically relies on training separate models on bootstrap samples of a potentially large amount of training data, which is expensive. Multi-task tri-training (MT-Tri) (Ruder and Plank, 2018) aims to reduce both the time and space complexity of tri-training by leveraging insights from multi-task learning (MTL) (Caruana, 1993) [<sup id="fnref:23"><a href="index.html#fn:23" rel="footnote">23</a></sup>] to share knowledge across models and accelerate training. Rather than storing and training each model separately, MT-Tri shares the parameters of the models and trains them jointly using MTL. Note that the model does only <em>pseudo</em> MTL as all three models effectively perform the same task.</p>

<p>The output softmax layers are model-specific and are only updated for the input of the respective model. As the models leverage a joint representation, diversity is even more crucial. We need to ensure that the features used for prediction in the softmax layers of the different models are as diverse as possible, so that the models can still learn from each other's predictions. In contrast, if the parameters in all output softmax layers were the same, the method would degenerate to self-training. Similar to pseudo-view regularization, we thus use an orthogonality constraint (Bousmalis et al., 2016) on two of the three softmax output layers as an additional loss term. </p>

<p>The pseudo-code can be seen below. In contrast to classic tri-training, we can train the multi-task model with its three model-specific outputs jointly and <em>without</em> bootstrap sampling on the labeled source domain data until convergence, as the orthogonality constraint enforces different representations between models \(m_1\) and \(m_2\). From this point, we can leverage the pair-wise agreement of two output layers to add pseudo-labeled examples as training data to the third model. We train the third output layer \(m_3\) only on pseudo-labeled target instances in order to make tri-training more robust to a domain shift. For the final prediction, we use majority voting of all three output layers. For more information about multi-task tri-training, self-training, other tri-training variants, you can refer to our recent <a href="https://arxiv.org/abs/1804.09530">ACL 2018 paper</a>. <br>
<img src="../content/images/2018/04/multi-task_tri-training-1.png" alt=""></p>

<h2 id="selfensembling"> Self-ensembling</h2>

<p>Self-ensembling methods are very similar to multi-view learning approaches in that they combine different variants of a model. Multi-task tri-training, for instance, can also be seen as a self-ensembling method where different variations of a model are used to create a stronger ensemble prediction. In contrast to multi-view learning, diversity is not a key concern. Self-ensembling approaches mostly use a single model under different configurations in order to make the model's predictions more robust. Most of the following methods are very recent and several have achieved state-of-the-art results in computer vision.</p>

<p><strong>Ladder networks</strong>   The \(\Gamma\) (gamma) version of Ladder Networks (Rasmus et al., 2015) [<sup id="fnref:24"><a href="index.html#fn:24" rel="footnote">24</a></sup>] aims to make a model more robust to noise. For each unlabelled example, it uses the model's prediction on the clean example as a proxy label for prediction on a perturbed version of the example. This way, the model learns to develop features that are invariant to noise and predictive of the labels on the labelled training data. Ladder networks have been mostly used in computer vision where many forms of perturbation and data augmentation are available.</p>

<p><strong>Virtual Adversarial Training</strong>   If perturbing the original sample is not possible or desired, we can instead perturb the example in feature space. Rather than randomly perturbing it by e.g. adding dropout, we can apply the <em>worst possible</em> perturbation for the model, which transforms the input into an adversarial sample. While adversarial training requires access to the labels to perform these perturbations, <em>virtual</em> adversarial training (Miyato et al., 2017) [<sup id="fnref:25"><a href="index.html#fn:25" rel="footnote">25</a></sup>] requires no labels and is thus suitable for semi-supervised learning. Virtual adversarial training effectively seeks to make the model robust to perturbations in directions to which it is most sensitive and has achieved good results on text classification datasets.</p>

<p><strong>\(\Pi\) model</strong>   Rather than treating clean predictions as proxy labels, the \(\Pi\) (pi) model (Laine and Aila, 2017) [<sup id="fnref:27"><a href="index.html#fn:27" rel="footnote">27</a></sup>] ensembles the predictions of the model under two different perturbations of the input data and two different dropout conditions \(z\) and \(\tilde{z}\). The full pseudo-code can be seen in Algorithm 6 below. \(g(x)\) is the stochastic input augmentation function. The first loss term encourages the predictions under the two different noise settings to be consistent, with \(\lambda\) determining the contribution, while the second loss term is the standard cross-entropy loss \(H\) with respect to the label \(y\). In contrast to the models we encountered before, we apply the unsupervised loss component to both unlabelled and labelled examples.
<img src="../content/images/2018/04/pi-model-3.png" alt="">
<strong>Temporal Ensembling</strong>   Instead of ensembling over the same model under different noise configurations, we can ensemble over different models. As training separate models is expensive, we can instead ensemble the predictions of a model <em>at different timesteps</em>. We can save the ensembled proxy labels \(Z\) as an exponential moving average of the model's past predictions on all examples as depicted below in order to save space. As we initialize the proxy labels as a zero vector, they are biased towards \(0\). We can correct this bias similar to Adam (Kingma and Ba, 2015) [<sup id="fnref:28"><a href="index.html#fn:28" rel="footnote">28</a></sup>] based on the current epoch \(t\) to obtain bias-corrected target vectors \(\tilde{z}\). We then update the model similar to the \(\Pi\) model. 
<img src="../content/images/2018/04/temporal_ensembling-3.png" alt=""></p>

<p><strong>Mean Teacher</strong>   Finally, instead of averaging the <em>predictions</em> of our model over training time, we can average the model weights. Mean teacher (Tarvainen and Valpola, 2017) [<sup id="fnref:29"><a href="index.html#fn:29" rel="footnote">29</a></sup>] stores an exponential moving average of the model parameters. For every example, this mean teacher model is then used to obtain proxy labels \(\tilde{z}\). The consistency loss and supervised loss are computed as in temporal ensembling.</p>

<p>Mean teacher has achieved state-of-the-art results for semi-supervised learning for computer vision. For reference, on ImageNet with 10% of the labels, it achieves an error rate of \(9.11\), compared to an error rate of \(3.79\) using <em>all</em> labels with the state-of-the-art. For more information about self-ensembling methods, have a look at <a href="https://thecuriousaicompany.com/mean-teacher/">this intuitive blog post</a> by the Curious AI company. We have run experiments with temporal ensembling for NLP tasks, but did not manage to obtain consistent results. My assumption is that the unsupervised consistency loss is more suitable for continuous inputs. Mean teacher might work better, as averaging weights aka Polyak averaging (Polyak and Juditsky, 1992) [<sup id="fnref:33"><a href="index.html#fn:33" rel="footnote">33</a></sup>] is a tried method for accelerating optimization.</p>

<p>Very recently, Oliver et al. (2018) [<sup id="fnref:39"><a href="index.html#fn:39" rel="footnote">39</a></sup>] raise some questions regarding the true applicability of these methods: They find that the performance difference to a properly tuned supervised baseline is smaller than typically reported, that transfer learning from a labelled dataset (e.g. ImageNet) outperforms the presented methods, and that performance degrades severely under a domain shift. In order to deal with the latter, algorithms such as asymmetric or multi-task tri-training learn different representations for the target distribution. It remains to be seen if these insights translate to other domains; a combination of transfer learning and semi-supervised adaptation to the target domain seems particularly promising.</p>

<h2 id="relatedmethodsandareas"> Related methods and areas</h2>

<p><strong>Distillation</strong>   Proxy-label approaches can be seen as different forms of distillation (Hinton et al., 2015) [<sup id="fnref:30"><a href="index.html#fn:30" rel="footnote">30</a></sup>]. Distillation was originally conceived as a method to compress the information of a large model or an ensemble in a smaller model. In the standard setup, a typically large and fully trained <em>teacher</em> model provides proxy targets for a <em>student</em> model, which is generally smaller and faster. Self-learning is akin to distillation without a teacher, where the student is left to learn by themselves and with no-one to correct its mistakes. For multi-view learning, different models work together to teach each other, alternately acting as both teachers and students. Self-ensembling, finally, has one model assuming the dual role of teacher and student: As a teacher, it generates new targets, which are then incorporated by itself as a student for learning.</p>

<p><strong>Learning from weak supervision</strong>   Learning from weak supervision, as the name implies, can be seen as a weaker form of supervised learning or alternatively as a stronger form of semi-supervised learning: While supervised learning provides us with labels that we know to be correct and semi-supervised learning only provides us with a small set of labelled examples, weak supervision allows us to obtain labels that we know to be noisy for the unlabelled data as a further signal for learning. Typically, the weak annotator is an unsupervised method that is very different from the model we use for learning the task. For sentiment analysis, this could be a simple lexicon-based method [<sup id="fnref:35"><a href="index.html#fn:35" rel="footnote">35</a></sup>]. Many of the presented methods could be extended to the weak supervision setting by incorporating the weak labels as feedback. Self-ensembling methods, for instance, might employ another teacher model that gauges the quality of weakly annotated examples similar to Deghani et al. (2018) [<sup id="fnref:34"><a href="index.html#fn:34" rel="footnote">34</a></sup>]. For an overview of weak supervision, have a look at <a href="https://hazyresearch.github.io/snorkel/blog/ws_blog_post.html">this blog post</a> by Stanford's Hazy Research group.</p>

<p><strong>Learning with noisy labels</strong>   Learning with noisy labels is similar to learning from weak supervision. In both cases, labels are available that cannot be completely trusted. For learning with noisy labels, labels are typically assumed to be permuted with a fixed random permutation. While proxy-label approaches supply the noisy labels themselves, when learning with noisy labels, the labels are part of the data. Similar to learning from weak supervision, we can try to model the noise to assess the quality of the labels (Sukhbaatar et al., 2015) [<sup id="fnref:37"><a href="index.html#fn:37" rel="footnote">37</a></sup>]. Similar to self-ensembling methods, we can enforce consistency between the model's preditions and the proxy labels (Reed et al., 2015) [<sup id="fnref:36"><a href="index.html#fn:36" rel="footnote">36</a></sup>].</p>

<p><strong>Data augmentation</strong>   Several self-ensembling methods employ data augmentation to enforce consistency between model predictions under different noise settings. Data augmentation is mostly used in computer vision, but  noise in the form of different dropout masks can also be applied to the model parameters as in the \(\Pi\) model and has also been used in LSTMs (Zolna et al., 2018) [<sup id="fnref:38"><a href="index.html#fn:38" rel="footnote">38</a></sup>]. While regularization in the form of dropout, batch normalization, etc. can be used when labels are available in order to make predictions more robust, a consistency loss is required in the case without labels. For supervised learning, adversarial training can be employed to obtain adversarial examples and has been used successfully e.g. for part-of-speech tagging (Yasunaga et al., 2018) [<sup id="fnref:26"><a href="index.html#fn:26" rel="footnote">26</a></sup>]. </p>

<p><strong>Ensembling a single model</strong>   The discussed self-ensembling methods all employ ensemble predictions not just to make predictions more robust, but as feedback to improve the model itself during training in a self-reinforcing loop. In the supervised setting, this feedback might not be necessary; ensembling a single model is still useful, however, to save time compared to training multiple models. Two methods that have been proposed to ensemble a model from a single training run are checkpoint ensembles and snapshot ensembles. Checkpoint ensembles (Sennrich et al., 2016) [<sup id="fnref:31"><a href="index.html#fn:31" rel="footnote">31</a></sup>] ensemble the last \(n\) checkpoints of a single training run and have been used to achieve state-of-the-art in machine translation. Snapshot ensembles (Huang et al., 2017) [<sup id="fnref:32"><a href="index.html#fn:32" rel="footnote">32</a></sup>] ensemble models converged to different minima during a training run and have been used to achieve state-of-the-art in object recognition. </p>

<h2 id="conclusion"> Conclusion</h2>

<p>I hope this post was able to give you an insight into a part of the semi-supervised learning landscape that seems to be particularly useful to improve the performance of current models. While learning completely without labelled data is unrealistic at this point, semi-supervised learning enables us to augment our small labelled datasets with large amounts of available unlabelled data. Most of the discussed methods are promising in that they treat the model as a black box and can thus be used with any existing supervised learning model. As always, if you have any questions or noticed any mistakes, feel free to write a comment in the comments section below.</p>

<h2 id="references"> References</h2>

<div class="footnotes"><ol><li class="footnote" id="fn:1"><p>Zhu, X. (2005). Semi-Supervised Learning Literature Survey. <a href="index.html#fnref:1" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:2"><p>Chapelle, O., Schölkopf, B., &amp; Zien, A. (2006). Semi-Supervised Learning. Interdisciplinary sciences computational life sciences (Vol. 1). <a href="http://doi.org/10.1007/s12539-009-0016-2">http://doi.org/10.1007/s12539-009-0016-2</a> <a href="index.html#fnref:2" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:3"><p>Kipf, T. N., &amp; Welling, M. (2017). Semi-Supervised Classification with Graph Convolutional Networks. Proceedings of ICLR 2017. <a href="index.html#fnref:3" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:4"><p>Yarowsky, D. (1995). Unsupervised word sense disambiguation rivaling supervised methods. In Proceedings of the 33rd annual meeting on Association for Computational Linguistics (pp. 189-196). Association for Computational Linguistics. <a href="index.html#fnref:4" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:5"><p>McClosky, D., Charniak, E., &amp; Johnson, M. (2006). Effective self-training for parsing. Proceedings of the Main Conference on Human Language Technology Conference of the North American Chapter of the Association of Computational Linguistics, 152–159. <a href="index.html#fnref:5" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:6"><p>Reichart, R., &amp; Rappoport, A. (2007). Self-training for enhancement and domain adaptation of statistical parsers trained on small datasets. In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics (pp. 616-623) <a href="index.html#fnref:6" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:7"><p>Suzuki, J., &amp; Isozaki, H. (2008). Semi-supervised sequential labeling and segmentation using giga-word scale unlabeled data. Proceedings of ACL-08: HLT, 665-673. <a href="index.html#fnref:7" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:8"><p>Petrov, S., &amp; McDonald, R. (2012). Overview of the 2012 shared task on parsing the web. In Notes of the first workshop on syntactic analysis of non-canonical language (sancl) (Vol. 59). <a href="index.html#fnref:8" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:9"><p>He, Y., &amp; Zhou, D. (2011). Self-training from labeled features for sentiment analysis. Information Processing &amp; Management, 47(4), 606-616. <a href="index.html#fnref:9" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:10"><p>Plank, B. (2011). Domain adaptation for parsing. University Library Groniongen][Host]. <a href="index.html#fnref:10" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:11"><p>Van Asch, V., &amp; Daelemans, W. (2016). Predicting the Effectiveness of Self-Training: Application to Sentiment Classification. arXiv preprint arXiv:1601.03288. <a href="index.html#fnref:11" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:12"><p>van der Goot, R., Plank, B., &amp; Nissim, M. (2017). To normalize, or not to normalize: The impact of normalization on part-of-speech tagging. arXiv preprint arXiv:1707.05116. <a href="index.html#fnref:12" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:13"><p>Huang, Z., &amp; Harper, M. (2009). Self-training PCFG grammars with latent annotations across languages. In Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing: Volume 2-Volume 2 (pp. 832-841). Association for Computational Linguistics. <a href="index.html#fnref:13" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:14"><p>Zhou, Z.-H., &amp; Li, M. (2005). Tri-Training: Exploiting Unlabled Data Using Three Classifiers. IEEE Trans.Data Eng., 17(11), 1529–1541. <a href="http://doi.org/10.1109/TKDE.2005.186">http://doi.org/10.1109/TKDE.2005.186</a> <a href="index.html#fnref:14" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:15"><p>Søgaard, A. (2010). Simple semi-supervised training of part-of-speech taggers. Proceedings of the ACL 2010 Conference Short Papers. <a href="index.html#fnref:15" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:16"><p>Saito, K., Ushiku, Y., &amp; Harada, T. (2017). Asymmetric Tri-training for Unsupervised Domain Adaptation. In ICML 2017. Retrieved from <a href="http://arxiv.org/abs/1702.08400">http://arxiv.org/abs/1702.08400</a> <a href="index.html#fnref:16" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:17"><p>Blum, A., &amp; Mitchell, T. (1998). Combining labeled and unlabeled data with co-training. In Proceedings of the eleventh annual conference on Computational learning theory (pp. 92-100). ACM. <a href="index.html#fnref:17" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:18"><p>Chen, M., Weinberger, K. Q., &amp; Blitzer, J. C. (2011). Co-Training for Domain Adaptation. In Advances in Neural Information Processing Systems. <a href="index.html#fnref:18" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:19"><p>Chen, M., Weinberger, K. Q., &amp; Chen, Y. (2011). Automatic Feature Decomposition for Single View Co-training. Proceedings of the 28th International Conference on Machine Learning (ICML-11), 953–960. <a href="index.html#fnref:19" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:20"><p>Bousmalis, K., Trigeorgis, G., Silberman, N., Krishnan, D., &amp; Erhan, D. (2016). Domain Separation Networks. In Advances in Neural Information Processing Systems. <a href="index.html#fnref:20" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:21"><p>Zhou, Y., &amp; Goldman, S. (2004). Democratic Co-Learning. In 16th IEEE International Conference on Tools with Artificial Intelligence, ICTAI 2004. <a href="index.html#fnref:21" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:22"><p>Ruder, S., &amp; Plank, B. (2018). Strong Baselines for Neural Semi-supervised Learning under Domain Shift. In Proceedings of ACL 2018. <a href="index.html#fnref:22" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:23"><p>Caruana, R. (1993). Multitask learning: A knowledge-based source of inductive bias. In Proceedings of the Tenth International Conference on Machine Learning. <a href="index.html#fnref:23" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:24"><p>Rasmus, A., Valpola, H., Honkala, M., Berglund, M., &amp; Raiko, T. (2015). Semi-Supervised Learning with Ladder Network. arXiv Preprint arXiv:1507.02672. Retrieved from <a href="http://arxiv.org/abs/1507.02672">http://arxiv.org/abs/1507.02672</a> <a href="index.html#fnref:24" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:25"><p>Miyato, T., Dai, A. M., &amp; Goodfellow, I. (2017). Adversarial Training Methods for Semi-supervised Text Classification. In Proceedings of ICLR 2017. <a href="index.html#fnref:25" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:26"><p>Yasunaga, M., Kasai, J., &amp; Radev, D. (2018). Robust Multilingual Part-of-Speech Tagging via Adversarial Training. In Proceedings of NAACL 2018. Retrieved from <a href="http://arxiv.org/abs/1711.04903">http://arxiv.org/abs/1711.04903</a> <a href="index.html#fnref:26" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:27"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="index.html#fnref:27" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:28"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="index.html#fnref:28" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:29"><p>Tarvainen, A., &amp; Valpola, H. (2017). Mean teachers are better role models: Weight-averaged consistency targets improve semi-supervised deep learning results. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1703.01780">http://arxiv.org/abs/1703.01780</a> <a href="index.html#fnref:29" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:30"><p>Hinton, G., Vinyals, O., &amp; Dean, J. (2015). Distilling the Knowledge in a Neural Network. arXiv Preprint arXiv:1503.02531. <a href="https://doi.org/10.1063/1.4931082">https://doi.org/10.1063/1.4931082</a> <a href="index.html#fnref:30" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:31"><p>Sennrich, R., Haddow, B., &amp; Birch, A. (2016). Edinburgh neural machine translation systems for WMT 16. arXiv preprint arXiv:1606.02891. <a href="index.html#fnref:31" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:32"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="index.html#fnref:32" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:33"><p>Polyak, B. T., &amp; Juditsky, A. B. (1992). Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization, 30(4), 838-855. <a href="index.html#fnref:33" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:34"><p>Dehghani, M., Mehrjou, A., Gouws, S., Kamps, J., &amp; Schölkopf, B. (2018). Fidelity-Weighted Learning. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.02799">http://arxiv.org/abs/1711.02799</a> <a href="index.html#fnref:34" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:35"><p>Kiritchenko, S., Zhu, X., &amp; Mohammad, S. M. (2014). Sentiment analysis of short informal texts. Journal of Artificial Intelligence Research, 50, 723-762. <a href="index.html#fnref:35" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:36"><p>Reed, S., Lee, H., Anguelov, D., Szegedy, C., Erhan, D., &amp; Rabinovich, A. (2015). Training Deep Neural Networks on Noisy Labels with Bootstrapping. ICLR 2015 Workshop Track. Retrieved from <a href="http://arxiv.org/abs/1412.6596">http://arxiv.org/abs/1412.6596</a> <a href="index.html#fnref:36" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:37"><p>Sukhbaatar, S., Bruna, J., Paluri, M., Bourdev, L., &amp; Fergus, R. (2015). Training Convolutional Networks with Noisy Labels. Workshop Track - ICLR 2015. Retrieved from <a href="http://arxiv.org/abs/1406.2080">http://arxiv.org/abs/1406.2080</a> <a href="index.html#fnref:37" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:38"><p>Zolna, K., Arpit, D., Suhubdy, D., &amp; Bengio, Y. (2018). Fraternal Dropout. In Proceedings of ICLR 2018. Retrieved from <a href="http://arxiv.org/abs/1711.00066">http://arxiv.org/abs/1711.00066</a> <a href="index.html#fnref:38" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:39"><p>Oliver, A., Odena, A., Raffel, C., Cubuk, E. D., &amp; Goodfellow, I. J. (2018). Realistic Evaluation of Semi-Supervised Learning Algorithms. arXiv preprint arXiv:1804.09170. <a href="index.html#fnref:39" title="return to article">↩</a></p></li></ol></div>
    </div>

    <div class="post related">
        <a rel="prev" id="prev-btn" class="btn small square" href="../text-classification-tensorflow-estimators/">← Text Classification with TensorFlow Estimators</a>

        <a rel="next" id="next-btn" class="btn small square" href="../highlights-naacl-2018/">Highlights of NAACL-HLT 2018: Generalization, Test-of-time, and Dialogue Systems →</a>
    </div>

    <footer class="post comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</footer>

  </article>


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>  

        <footer>
  <span class="copyright">
    © 2018. All rights reserved. Built with <a href="https://ghost.org/" target="_blank">Ghost</a> and <a href="https://github.com/Kikobeats/uno-zen" target="_blank">Uno Zen</a> theme.
  </span>
</footer>
      </section>
    </main>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
    <script src="../assets/js/uno-zen.js?v=048ab6045a" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
  if (window.ga_id) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', window.ga_id, 'auto');
    ga('require', 'linkid', 'linkid.js');
    ga('send', 'pageview');
  }
</script>
  </body>
