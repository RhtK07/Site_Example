
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Optimization for Deep Learning Highlights in 2017</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="../assets/built/screen.css?v=598e4ecdd9">

    <meta name="description" content="An overview of the most exciting highlights and research directions in optimization for Deep Learning in 2017.">
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="canonical" href="http://ruder.io/deep-learning-optimization-2017/">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="http://ruder.io/deep-learning-optimization-2017/amp/">
    
    <meta property="og:site_name" content="Sebastian Ruder">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Optimization for Deep Learning Highlights in 2017">
    <meta property="og:description" content="Different gradient descent optimization algorithms have been proposed in recent years but Adam is still most commonly used. This post discusses the most exciting highlights and most promising recent approaches that may shape the way we will optimize our models in the future.">
    <meta property="og:url" content="http://ruder.io/deep-learning-optimization-2017/">
    <meta property="og:image" content="http://ruder.io/content/images/2017/12/snapshot_ensembles.png">
    <meta property="article:published_time" content="2017-12-03T15:36:00.000Z">
    <meta property="article:modified_time" content="2018-10-24T11:56:07.000Z">
    <meta property="article:tag" content="optimization">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Optimization for Deep Learning Highlights in 2017">
    <meta name="twitter:description" content="Different gradient descent optimization algorithms have been proposed in recent years but Adam is still most commonly used. This post discusses the most exciting highlights and most promising recent approaches that may shape the way we will optimize our models in the future.">
    <meta name="twitter:url" content="http://ruder.io/deep-learning-optimization-2017/">
    <meta name="twitter:image" content="http://ruder.io/content/images/2017/12/snapshot_ensembles.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Sebastian Ruder">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="optimization">
    <meta name="twitter:site" content="@seb_ruder">
    <meta name="twitter:creator" content="@seb_ruder">
    <meta property="og:image:width" content="1498">
    <meta property="og:image:height" content="635">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Sebastian Ruder",
        "logo": {
            "@type": "ImageObject",
            "url": "http://ruder.io/favicon.ico",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "image": {
            "@type": "ImageObject",
            "url": "http://ruder.io/content/images/2019/02/new_profile_photo_square.jpg",
            "width": 2000,
            "height": 2000
        },
        "url": "http://ruder.io/author/sebastian/",
        "sameAs": [
            "https://twitter.com/seb_ruder"
        ]
    },
    "headline": "Optimization for Deep Learning Highlights in 2017",
    "url": "http://ruder.io/deep-learning-optimization-2017/",
    "datePublished": "2017-12-03T15:36:00.000Z",
    "dateModified": "2018-10-24T11:56:07.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://ruder.io/content/images/2017/12/snapshot_ensembles.png",
        "width": 1498,
        "height": 635
    },
    "keywords": "optimization",
    "description": "Different gradient descent optimization algorithms have been proposed in recent years but Adam is still most commonly used. This post discusses the most exciting highlights and most promising recent approaches that may shape the way we will optimize our models in the future.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://ruder.io/"
    }
}
    </script>

    <script src="../public/ghost-sdk.js?v=598e4ecdd9"></script>
<script>
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "bc1baff4b81d"
});
</script>
    <meta name="generator" content="Ghost 2.11">
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="http://ruder.io/rss/">
    <script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        processEscapes: true
    }
});
</script>

</head>
<body class="post-template tag-optimization">

    <div class="site-wrapper">

        

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
                <a class="site-nav-logo" href="http://ruder.io">Sebastian Ruder</a>
            <ul class="nav" role="menu">
    <li class="nav-about" role="menuitem"><a href="http://ruder.io/about/">About</a></li>
    <li class="nav-tags" role="menuitem"><a href="http://ruder.io/tags/">Tags</a></li>
    <li class="nav-papers" role="menuitem"><a href="http://ruder.io/publications/">Papers</a></li>
    <li class="nav-talks" role="menuitem"><a href="http://ruder.io/talks/">Talks</a></li>
    <li class="nav-news" role="menuitem"><a href="http://ruder.io/news/">News</a></li>
    <li class="nav-faq" role="menuitem"><a href="http://ruder.io/faq/">FAQ</a></li>
    <li class="nav-nlp-news" role="menuitem"><a href="http://ruder.io/nlp-news/">NLP News</a></li>
    <li class="nav-nlp-progress" role="menuitem"><a href="https://nlpprogress.com/">NLP Progress</a></li>
</ul>

    </div>
    <div class="site-nav-right">
        <div class="social-links">
                <a class="social-link social-link-tw" href="https://twitter.com/seb_ruder" title="Twitter" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
</a>
        </div>
            <a class="rss-button" href="http://ruder.io/rss/index.rss" title="RSS" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><circle cx="6.18" cy="17.82" r="2.18"></circle><path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"></path></svg>
</a>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer">
    <div class="inner">

        <article class="post-full post tag-optimization ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="2017-12-03">3 December 2017</time>
                        <span class="date-divider">/</span> <a href="../tag/optimization/">optimization</a>
                </section>
                <h1 class="post-full-title">Optimization for Deep Learning Highlights in 2017</h1>
            </header>

            <figure class="post-full-image">
                <img srcset="http://ruder.io/content/images/size/w300/2017/12/snapshot_ensembles.png 300w,
                            http://ruder.io/content/images/size/w600/2017/12/snapshot_ensembles.png 600w,
                            http://ruder.io/content/images/size/w1000/2017/12/snapshot_ensembles.png 1000w,
                            http://ruder.io/content/images/size/w2000/2017/12/snapshot_ensembles.png 2000w" sizes="(max-width: 800px) 400px,
                            (max-width: 1170px) 700px,
                            1400px" src="http://ruder.io/content/images/size/w2000/2017/12/snapshot_ensembles.png" alt="Optimization for Deep Learning Highlights in 2017">
            </figure>

            <section class="post-full-content">
                <div class="post-content">
                    <p>This post discusses the most exciting highlights and most promising directions in optimization for Deep Learning.</p>
<p>Table of contents:</p>
<ul>
<li><a href="index.html#improvingadam">Improving Adam</a></li>
<li><a href="index.html#decouplingweightdecay">Decoupling weight decay</a></li>
<li><a href="index.html#fixingtheexponentialmovingaverage">Fixing the exponential moving average</a></li>
<li><a href="index.html#tuningthelearningrate">Tuning the learning rate</a></li>
<li><a href="index.html#warmrestarts">Warm restarts</a></li>
<li><a href="index.html#sgdwithrestarts">SGD with restarts</a></li>
<li><a href="index.html#snapshotensembles">Snapshot ensembles</a></li>
<li><a href="index.html#adamwithrestarts">Adam with restarts</a></li>
<li><a href="index.html#learningtooptimize">Learning to optimize</a></li>
<li><a href="index.html#understandinggeneralization">Understanding generalization</a></li>
</ul>
<p>Deep Learning ultimately is about finding a minimum that generalizes well -- with bonus points for finding one fast and reliably. Our workhorse, stochastic gradient descent (SGD), is a 60-year old algorithm (Robbins and Monro, 1951) <sup class="footnote-ref"><a href="index.html#fn1" id="fnref1">[1]</a></sup>, that is as essential to the current generation of Deep Learning algorithms as back-propagation.</p>
<p>Different optimization algorithms have been proposed in recent years, which use different equations to update a model's parameters. Adam (Kingma and Ba, 2015) <sup class="footnote-ref"><a href="index.html#fn2" id="fnref2">[2]</a></sup> was introduced in 2015 and is arguably today still the most commonly used one of these algorithms. This indicates that from the Machine Learning practitioner's perspective, best practices for optimization for Deep Learning have largely remained the same.</p>
<p>New ideas, however, have been developed over the course of this year, which may shape the way we will optimize our models in the future. In this blog post, I will touch on the most exciting highlights and most promising directions in optimization for Deep Learning in my opinion. Note that this blog post assumes a familiarity with SGD and with adaptive learning rate methods such as Adam. To get up to speed, refer to <a href="http://ruder.io/optimizing-gradient-descent/index.html">this blog post</a> for an overview of existing gradient descent optimization algorithms.</p>
<h2 id="improvingadam">Improving Adam</h2>
<p>Despite the apparent supremacy of adaptive learning rate methods such as Adam, state-of-the-art results for many tasks in computer vision and NLP such as object recognition (Huang et al., 2017) <sup class="footnote-ref"><a href="index.html#fn3" id="fnref3">[3]</a></sup> or machine translation (Wu et al., 2016) <sup class="footnote-ref"><a href="index.html#fn4" id="fnref4">[4]</a></sup> have still been achieved by plain old SGD with momentum. Recent theory (Wilson et al., 2017) <sup class="footnote-ref"><a href="index.html#fn5" id="fnref5">[5]</a></sup> provides some justification for this, suggesting that adaptive learning rate methods converge to different (and less optimal) minima than SGD with momentum. It is empirically shown that the minima found by adaptive learning rate methods perform generally worse compared to those found by SGD with momentum on object recognition, character-level language modeling, and constituency parsing. This seems counter-intuitive given that Adam comes with nice convergence guarantees and that its adaptive learning rate should give it an edge over the regular SGD. However, Adam and other adaptive learning rate methods are not without their own flaws.</p>
<h3 id="decouplingweightdecay">Decoupling weight decay</h3>
<p>One factor that partially accounts for Adam's poor generalization ability compared with SGD with momentum on some datasets is weight decay. Weight decay is most commonly used in image classification problems and decays the weights \(\theta_t\) after every parameter update by multiplying them by a decay rate \(w_t\) that is slightly less than \(1\):</p>
<p>\(\theta_{t+1} = w_t : \theta_t \)</p>
<p>This prevents the weights from growing too large. As such, weight decay can also be understood as an \(\ell_2\) regularization term that depends on the weight decay rate \(w_t\) added to the loss:</p>
<p>\(\mathcal{L}_\text{reg} = \dfrac{w_t}{2} |\theta_t |^2_2 \)</p>
<p>Weight decay is commonly implemented in many neural network libraries either as the above regularization term or directly to modify the gradient. As the gradient is modified in both the momentum and Adam update equations (via multiplication with other decay terms), weight decay no longer equals \(\ell_2\) regularization. Loshchilov and Hutter (2017) <sup class="footnote-ref"><a href="index.html#fn6" id="fnref6">[6]</a></sup> thus propose to decouple weight decay from the gradient update by adding it after the parameter update as in the original definition.<br>
The SGD with momentum and weight decay (SGDW) update then looks like the following:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
v_t &amp;= \gamma v_{t-1} + \eta g_t \\<br>
\theta_{t+1} &amp;= \theta_t - v_t - \eta w_t \theta_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>where \(\eta\) is the learning rate and the third term in the second equation is the decoupled weight decay. Similarly, for Adam with weight decay (AdamW) we obtain:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\<br>
\hat{m}_t &amp;= \dfrac{m_t}{1 - \beta^t_1} \\<br>
\hat{v}_t &amp;= \dfrac{v_t}{1 - \beta^t_2} \\<br>
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t - \eta w_t \theta_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>where \(m_t\) and \(\hat{m}_t\) and \(v_t\) and \(\hat{v}_t\) are the biased and bias-corrected estimates of the first and second moments respectively and \(\beta_1\) and \(\beta_2\) are their decay rates, with the same weight decay term added to it. The authors show that this substantially improves Adam’s generalization performance and allows it to compete with SGD with momentum on image classification datasets.</p>
<p>In addition, it decouples the choice of the learning rate from the choice of the weight decay, which enables better hyperparameter optimization as the hyperparameters no longer depend on each other. It also separates the implementation of the optimizer from the implementation of the weight decay, which contributes to cleaner and more reusable code (see e.g. the <a href="https://github.com/fastai/fastai/pull/46/files">fast.ai AdamW/SGDW implementation</a>).</p>
<h3 id="fixingtheexponentialmovingaverage">Fixing the exponential moving average</h3>
<p>Several recent papers (Dozat and Manning, 2017; Laine and Aila, 2017) <sup class="footnote-ref"><a href="index.html#fn7" id="fnref7">[7]</a></sup>,<sup class="footnote-ref"><a href="index.html#fn8" id="fnref8">[8]</a></sup> empirically find that a lower \(\beta_2\) value, which controls the contribution of the exponential moving average of past squared gradients in Adam, e.g. \(0.99\) or \(0.9\) vs. the default \(0.999\) worked better in their respective applications, indicating that there might be an issue with the exponential moving average.</p>
<p>An <a href="https://openreview.net/forum?id=ryQu7f-RZ">ICLR 2018 submission</a> formalizes this issue and pinpoints the exponential moving average of past squared gradients as another reason for the poor generalization behaviour of adaptive learning rate methods. Updating the parameters via an exponential moving average of past squared gradients is at the heart of adaptive learning rate methods such as Adadelta, RMSprop, and Adam. The contribution of the exponential average is well-motivated: It should prevent the learning rates to become infinitesimally small as training progresses, the key flaw of the Adagrad algorithm. However, this short-term memory of the gradients becomes an obstacle in other scenarios.</p>
<p>In settings where Adam converges to a suboptimal solution, it has been observed that some minibatches provide large and informative gradients, but as these minibatches only occur rarely, exponential averaging diminishes their influence, which leads to poor convergence. The authors provide an example for a simple convex optimization problem where the same behaviour can be observed for Adam.</p>
<p>To fix this behaviour, the authors propose a new algorithm, AMSGrad that uses the maximum of past squared gradients rather than the exponential average to update the parameters. The full AMSGrad update without bias-corrected estimates can be seen below:</p>
<p>\(<br>
\begin{align}<br>
\begin{split}<br>
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\<br>
\hat{v}_t &amp;= \text{max}(\hat{v}_{t-1}, v_t) \\<br>
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} m_t<br>
\end{split}<br>
\end{align}<br>
\)</p>
<p>The authors observe improved performance compared to Adam on small datasets and on CIFAR-10.</p>
<h2 id="tuningthelearningrate">Tuning the learning rate</h2>
<p>In many cases, it is not our models that require improvement and tuning, but our hyperparameters. Recent examples for language modelling demonstrate that tuning LSTM parameters (Melis et al., 2017) <sup class="footnote-ref"><a href="index.html#fn9" id="fnref9">[9]</a></sup> and regularization parameters (Merity et al., 2017) <sup class="footnote-ref"><a href="index.html#fn10" id="fnref10">[10]</a></sup> can yield state-of-the-art results compared to more complex models.</p>
<p>An important hyperparameter for optimization in Deep Learning is the learning rate \(\eta\). In fact, SGD has been shown to require a learning rate annealing schedule to converge to a good minimum in the first place. It is often thought that adaptive learning rate methods such as Adam are more robust to different learning rates, as they update the learning rate themselves. Even for these methods, however, there can be a large difference between a good and the optimal learning rate (psst... it's <a href="https://twitter.com/karpathy/status/801621764144971776">\(3e-4\)</a>).</p>
<p>Zhang et al. (2017) <sup class="footnote-ref"><a href="index.html#fn11" id="fnref11">[11]</a></sup> show that SGD with a tuned learning rate annealing schedule and momentum parameter is not only competitive with Adam, but also converges faster. On the other hand, while we might think that the adaptivity of Adam's learning rates might mimic learning rate annealing, an explicit annealing schedule can still be beneficial: If we add SGD-style learning rate annealing to Adam, it converges faster and outperforms SGD on Machine Translation (Denkowski and Neubig, 2017) <sup class="footnote-ref"><a href="index.html#fn12" id="fnref12">[12]</a></sup>.</p>
<p>In fact, learning rate annealing schedule engineering seems to be the new feature engineering as we can often find highly-tuned learning rate annealing schedules that improve the final convergence behaviour of our model. An interesting example of this is Vaswani et al. (2017) <sup class="footnote-ref"><a href="index.html#fn13" id="fnref13">[13]</a></sup>. While it is usual to see a model's hyperparameters being subjected to large-scale hyperparameter optimization, it is interesting to see a learning rate annealing schedule as the focus of the same attention to detail: The authors use Adam with \(\beta_1=0.9\), a non-default \(\beta_2=0.98\), \(\epsilon = 10^{-9}\), and arguably one of the most elaborate annealing schedules for the learning rate \(\eta\):</p>
<p>\(\eta  = d_\text{model}^{-0.5} \cdot \min(step\text{_}num^{-0.5}, step\text{_}num \cdot warmup\text{_}steps^{-1.5}) \)</p>
<p>where \(d_\text{model}\) is the number of parameters of the model and \(warmup\text{_}steps = 4000\).</p>
<p>Another recent paper by Smith et al. (2017) <sup class="footnote-ref"><a href="index.html#fn14" id="fnref14">[14]</a></sup> demonstrates an interesting connection between the learning rate and the batch size, two hyperparameters that are typically thought to be independent of each other: They show that decaying the learning rate is equivalent to increasing the batch size, while the latter allows for increased parallelism. Conversely, we can reduce the number of model updates and thus speed up training by increasing the learning rate and scaling the batch size. This has ramifications for large-scale Deep Learning, which can now repurpose existing training schedules with no hyperparameter tuning.</p>
<h2 id="warmrestarts">Warm restarts</h2>
<h3 id="sgdwithrestarts">SGD with restarts</h3>
<p>Another effective recent development is SGDR (Loshchilov and Hutter, 2017) <sup class="footnote-ref"><a href="index.html#fn15" id="fnref15">[15]</a></sup>, an SGD alternative that uses warm restarts instead of learning rate annealing. In each restart, the learning rate is initialized to some value and is scheduled to decrease. Importantly, the restart is warm as the optimization does not start from scratch but from the parameters to which the model converged during the last step. The key factor is that the learning rate is decreased with an aggressive cosine annealing schedule, which rapidly lowers the learning rate and looks like the following:</p>
<p>\(\eta_t = \eta_{min}^i + \dfrac{1}{2}(\eta_{max}^i - \eta_{min}^i)(1 + \text{cos}(\dfrac{T_{cur}}{T_i}\pi)) \)</p>
<p>where \(\eta_{min}^i\) and \(\eta_{max}^i\) are ranges for the learning rate during the \(i\)-th run, \(T_{cur}\) indicates how many epochs passed since the last restart, and \(T_i\) specifies the epoch of the next restart. The warm restart schedules for \(T_i=50\), \(T_i=100\), and \(T_i=200\) compared with regular learning rate annealing are shown in Figure 1.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/warm_restarts.png" style="width: 100%" title="Learning rate schedules with warm restarts">
<figcaption>Figure 1: Learning rate schedules with warm restarts (Loshchilov and Hutter,
 2017)</figcaption>
</figure>
<p>The high initial learning rate after a restart is used to essentially catapult the parameters out of the minimum to which they previously converged and to a different area of the loss surface. The aggressive annealing then enables the model to rapidly converge to a new and better solution. The authors empirically find that SGD with warm restarts requires 2 to 4 times fewer epochs than learning rate annealing and achieves comparable or better performance.</p>
<p>Learning rate annealing with warm restarts is also known as cyclical learning rates and has been originally proposed by Smith (2017) <sup class="footnote-ref"><a href="index.html#fn16" id="fnref16">[16]</a></sup>. Two more articles by students of <a href="http://www.fast.ai/">fast.ai</a> (which has recently started to teach this method) that discuss warm restarts and cyclical learning rates can be found <a href="https://medium.com/@bushaev/improving-the-way-we-work-with-learning-rate-5e99554f163b">here</a> and <a href="http://teleported.in/posts/cyclic-learning-rate/">here</a>.</p>
<h3 id="snapshotensembles">Snapshot ensembles</h3>
<p>Snapshot ensembles (Huang et al., 2017) <sup class="footnote-ref"><a href="index.html#fn17" id="fnref17">[17]</a></sup> are a clever, recent technique that uses warm restarts to assemble an ensemble essentially for free when training a single model. The method trains a single model until convergence with the cosine annealing schedule that we have seen above. It then saves the model parameters, performs a warm restart, and then repeats these steps \(M\) times. In the end, all saved model snapshots are ensembled. The common SGD optimization behaviour on an error surface compared to the behaviour of snapshot ensembling can be seen in Figure 2.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/snapshot_ensembles.png" style="width: 100%" title="Learning rate schedules with warm restarts">
<figcaption>Figure 2: SGD vs. snapshot ensemble (Huang et al., 2017)</figcaption>
</figure>
<p>The success of ensembling in general relies on the diversity of the individual models in the ensemble. Snapshot ensembling thus relies on the cosine annealing schedule's ability to enable the model to converge to a different local optimum after every restart. The authors demonstrate that this holds in practice, achieving state-of-the-art results on CIFAR-10, CIFAR-100, and SVHN.</p>
<h3 id="adamwithrestarts">Adam with restarts</h3>
<p>Warm restarts did not work originally with Adam due to its dysfunctional weight decay, which we have seen before. After fixing weight decay, Loshchilov and Hutter (2017) similarly extend Adam to work with warm restarts. They set \(\eta_{min}^i=0\) and \(\eta_{max}^i=1\), which yields:</p>
<p>\(\eta_t = 0.5 + 0.5 : \text{cos}(\dfrac{T_{cur}}{T_i}\pi))\)</p>
<p>They recommend to start with an initially small \(T_i\) (between \(1%\) and \(10%\) of the total number of epochs) and multiply it by a factor of \(T_{mult}\) (e.g. \(T_{mult}=2\)) at every restart.</p>
<h2 id="learningtooptimize">Learning to optimize</h2>
<p>One of the most interesting papers of last year (and <a href="https://www.reddit.com/r/MachineLearning/comments/5n53k7/d_results_from_the_best_paper_awards/">reddit's "Best paper name of 2016" winner</a>) was a paper by Andrychowicz et al. (2016) <sup class="footnote-ref"><a href="index.html#fn18" id="fnref18">[18]</a></sup> where they train an LSTM optimizer to provide the updates to the main model during training. Unfortunately, learning a separate LSTM optimizer or even using a pre-trained LSTM optimizer for optimization greatly increases the complexity of model training.</p>
<p>Another very influential learning-to-learn paper from this year uses an LSTM to generate model architectures in a domain-specific language (Zoph and Quoc, 2017) <sup class="footnote-ref"><a href="index.html#fn19" id="fnref19">[19]</a></sup>. While the search process requires vast amounts of resources, the discovered architectures can be used as-is to replace their existing counterparts. This search process has proved effective and found architectures that achieve state-of-the-art results on language modeling and results competitive with the state-of-the-art on CIFAR-10.</p>
<p>The same search principle can be applied to any other domain where key processes have been previously defined by hand. One such domain are optimization algorithms for Deep Learning. As we have seen before, optimization algorithms are more similar than they seem: All of them use a combination of an exponential moving average of past gradients (as in momentum) and of an exponential moving average of past squared gradients (as in Adadelta, RMSprop, and Adam) (Ruder, 2016) <sup class="footnote-ref"><a href="index.html#fn20" id="fnref20">[20]</a></sup>.</p>
<p>Bello et al. (2017) <sup class="footnote-ref"><a href="index.html#fn21" id="fnref21">[21]</a></sup> define a domain-specific language that consists of primitives useful for optimization such as these exponential moving averages. They then sample an update rule from the space of possible update rules, use this update rule to train a model, and update the RNN controller based on the performance of the trained model on the test set. The full procedure can be seen in Figure 3.</p>
<figure>
      <img src="http://ruder.io/content/images/2017/11/neural_optimizer_search.png" style="width: 100%" title="Neural Optimizer Search">
<figcaption>Figure 3: Neural Optimizer Search (Bello et al., 2017)</figcaption>
</figure>
<p>In particular, they discover two update equations, PowerSign and AddSign. The update equation for PowerSign is the following:</p>
<p>\( \theta_{t+1} = \theta_{t} - \alpha^{f(t)*<br>
\text{sign}(g_t)*\text{sign}(m_t)}*g_t \)</p>
<p>where \(\alpha\) is a hyperparameter that is often set to \(e\) or \(2\), \(f(t)\) is either \(1\) or a decay function that performs linear, cyclical or decay with restarts based on time step \(t\), and \(m_t\) is the moving average of past gradients. The common configuration uses \(\alpha=e\) and no decay.  We can observe that the update scales the gradient by \(\alpha^{f(t)}\) or \(1/\alpha^{f(t)}\) depending on whether the direction of the gradient and its moving average agree. This indicates that this momentum-like agreement between past gradients and the current one is a key piece of information for optimizing Deep Learning models.</p>
<p>AddSign in turn is defined as follows:</p>
<p>\( \theta_{t+1} = \theta_{t} - \alpha + f(t) * \text{sign}(g_t) * \text{sign}(m_t)) * g_t\)</p>
<p>with \(\alpha\) often set to \(1\) or \(2\). Similar to the above, this time the update scales \(\alpha + f(t)\) or \(\alpha - f(t)\) again depending on the agreement of the direction of the gradients. The authors show that PowerSign and AddSign outperform Adam, RMSprop, and SGD with momentum on CIFAR-10 and transfer well to other tasks such as ImageNet classification and machine translation.</p>
<h2 id="understandinggeneralization">Understanding generalization</h2>
<p>Optimization is closely tied to generalization as the minimum to which a model converges defines how well the model generalizes. Advances in optimization are thus closely correlated with theoretical advances in understanding the generalization behaviour of such minima and more generally of gaining a deeper understanding of generalization in Deep Learning.</p>
<p>However, our understanding of the generalization behaviour of deep neural networks is still very shallow. Recent work showed that the number of possible local minima grows exponentially with the number of parameters (Kawaguchi, 2016) <sup class="footnote-ref"><a href="index.html#fn22" id="fnref22">[22]</a></sup>. Given the huge number of parameters of current Deep Learning architectures, it still seems almost magical that such models converge to solutions that generalize well, in particular given that they can completely memorize random inputs (Zhang et al., 2017) <sup class="footnote-ref"><a href="index.html#fn23" id="fnref23">[23]</a></sup>.</p>
<p>Keskar et al. (2017) <sup class="footnote-ref"><a href="index.html#fn24" id="fnref24">[24]</a></sup> identify the sharpness of a minimum as a source for poor generalization: In particular, they show that sharp minima found by batch gradient descent have high generalization error. This makes intuitive sense, as we generally would like our functions to be smooth and a sharp minima indicates a high irregularity in the corresponding error surface. However, more recent work suggests that sharpness may not be such a good indicator after all by showing that local minima that generalize well can be made arbitrarily sharp (Dinh et al., 2017) <sup class="footnote-ref"><a href="index.html#fn25" id="fnref25">[25]</a></sup>. A <a href="https://www.quora.com/Why-is-the-paper-%E2%80%9CUnderstanding-Deep-Learning-Requires-Rethinking-Generalization%E2%80%9D-important/answer/Eric-Jang?srid=dWc3">Quora answer by Eric Jang</a> also discusses these articles.</p>
<p>An <a href="https://openreview.net/forum?id=r1iuQjxCZ">ICLR 2018 submission</a> demonstrates through a series of ablation analyses that a model's reliance on single directions in activation space, i.e. the activation of single units or feature maps is a good predictor of its generalization performance. They show that this holds across models trained on different datasets and for different degrees of label corruption. They find that dropout does not help to resolve this, while batch normalization discourages single direction reliance.</p>
<p>While these findings indicate that there is still much we do not know in terms of Optimization for Deep Learning, it is important to remember that convergence guarantees and a large body of work exists for convex optimization and that existing ideas and insights can also be applied to non-convex optimization to some extent. The large-scale optimization tutorial at NIPS 2016 provides an excellent overview of more theoretical work in this area (see the <a href="https://www.di.ens.fr/~fbach/fbach_tutorial_vr_nips_2016.pdf">slides part 1</a>, <a href="http://suvrit.de/talks/vr_nips16_sra.pdf">part 2</a>, and the <a href="https://channel9.msdn.com/Events/Neural-Information-Processing-Systems-Conference/Neural-Information-Processing-Systems-Conference-NIPS-2016/Large-Scale-Optimization-Beyond-Stochastic-Gradient-Descent-and-Convexity">video</a>).</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope that I was able to provide an impression of some of the compelling developments in optimization for Deep Learning over the past year. I've undoubtedly failed to mention many other approaches that are equally important and noteworthy. Please let me know in the comments below what I missed, where I made a mistake or misrepresented a method, or which aspect of optimization for Deep Learning you find particularly exciting or underexplored.</p>
<h2 id="hackernews">Hacker News</h2>
<p>You can find the discussion of this post on HN <a href="https://news.ycombinator.com/item?id=15839564">here</a>.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Robbins, H., &amp; Monro, S. (1951). A stochastic approximation method. The annals of mathematical statistics, 400-407. <a href="index.html#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="index.html#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Huang, G., Liu, Z., Weinberger, K. Q., &amp; van der Maaten, L. (2017). Densely Connected Convolutional Networks. In Proceedings of CVPR 2017. <a href="index.html#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. arXiv Preprint arXiv:1609.08144. <a href="index.html#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Wilson, A. C., Roelofs, R., Stern, M., Srebro, N., &amp; Recht, B. (2017). The Marginal Value of Adaptive Gradient Methods in Machine Learning. arXiv Preprint arXiv:1705.08292. Retrieved from <a href="http://arxiv.org/abs/1705.08292">http://arxiv.org/abs/1705.08292</a> <a href="index.html#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Loshchilov, I., &amp; Hutter, F. (2017). Fixing Weight Decay Regularization in Adam. arXiv Preprint arXi1711.05101. Retrieved from <a href="http://arxiv.org/abs/1711.05101">http://arxiv.org/abs/1711.05101</a> <a href="index.html#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Dozat, T., &amp; Manning, C. D. (2017). Deep Biaffine Attention for Neural Dependency Parsing. In ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1611.01734">http://arxiv.org/abs/1611.01734</a> <a href="index.html#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="index.html#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Melis, G., Dyer, C., &amp; Blunsom, P. (2017). On the State of the Art of Evaluation in Neural Language Models. In arXiv preprint arXiv:1707.05589. <a href="index.html#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Merity, S., Shirish Keskar, N., &amp; Socher, R. (2017). Regularizing and Optimizing LSTM Language Models. arXiv Preprint arXiv:1708.02182. Retrieved from <a href="https://arxiv.org/pdf/1708.02182.pdf">https://arxiv.org/pdf/1708.02182.pdf</a> <a href="index.html#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Zhang, J., Mitliagkas, I., &amp; Ré, C. (2017). YellowFin and the Art of Momentum Tuning. In arXiv preprint arXiv:1706.03471. <a href="index.html#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Denkowski, M., &amp; Neubig, G. (2017). Stronger Baselines for Trustable Results in Neural Machine Translation. In Workshop on Neural Machine Translation (WNMT). Retrieved from <a href="https://arxiv.org/abs/1706.09733">https://arxiv.org/abs/1706.09733</a> <a href="index.html#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. In Advances in Neural Information Processing Systems. <a href="index.html#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Smith, S. L., Kindermans, P.-J., &amp; Le, Q. V. (2017). Don’t Decay the Learning Rate, Increase the Batch Size. In arXiv preprint arXiv:1711.00489. Retrieved from <a href="http://arxiv.org/abs/1711.00489">http://arxiv.org/abs/1711.00489</a> <a href="index.html#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Loshchilov, I., &amp; Hutter, F. (2017). SGDR: Stochastic Gradient Descent with Warm Restarts. In Proceedings of ICLR 2017. <a href="https://doi.org/10.1002/fut">https://doi.org/10.1002/fut</a> <a href="index.html#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>Smith, Leslie N. "Cyclical learning rates for training neural networks." In Applications of Computer Vision (WACV), 2017 IEEE Winter Conference on, pp. 464-472. IEEE, 2017. <a href="index.html#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="index.html#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Andrychowicz, M., Denil, M., Gomez, S., Hoffman, M. W., Pfau, D., Schaul, T., &amp; de Freitas, N. (2016). Learning to learn by gradient descent by gradient descent. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1606.04474">http://arxiv.org/abs/1606.04474</a> <a href="index.html#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Zoph, B., &amp; Le, Q. V. (2017). Neural Architecture Search with Reinforcement Learning. In ICLR 2017. <a href="index.html#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Ruder, S. (2016). An overview of gradient descent optimization algorithms. arXiv Preprint arXiv:1609.04747. <a href="index.html#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Bello, I., Zoph, B., Vasudevan, V., &amp; Le, Q. V. (2017). Neural Optimizer Search with Reinforcement Learning. In Proceedings of the 34th International Conference on Machine Learning. <a href="index.html#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Kawaguchi, K. (2016). Deep Learning without Poor Local Minima. In Advances in Neural Information Processing Systems 29 (NIPS 2016). Retrieved from <a href="http://arxiv.org/abs/1605.07110">http://arxiv.org/abs/1605.07110</a> <a href="index.html#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Zhang, C., Bengio, S., Hardt, M., Recht, B., &amp; Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. In Proceedings of ICLR 2017. <a href="index.html#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Keskar, N. S., Mudigere, D., Nocedal, J., Smelyanskiy, M., &amp; Tang, P. T. P. (2017). On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima. In Proceedings of ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1609.04836">http://arxiv.org/abs/1609.04836</a> <a href="index.html#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Dinh, L., Pascanu, R., Bengio, S., &amp; Bengio, Y. (2017). Sharp Minima Can Generalize For Deep Nets. In Proceedings of the 34th International Conference on Machine Learning. <a href="index.html#fnref25" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

                </div>
            </section>


            <footer class="post-full-footer">


                    
<section class="author-card">
        <img class="author-profile-image" src="http://ruder.io/content/images/size/w100/2019/02/new_profile_photo_square.jpg" alt="Sebastian Ruder">
    <section class="author-card-content">
        <h4 class="author-card-name"><a href="../author/sebastian/">Sebastian Ruder</a></h4>
            <p>Read <a href="../author/sebastian/">more posts</a> by this author.</p>
    </section>
</section>
<div class="post-full-footer-right">
    <a class="author-card-button" href="../author/sebastian/">Read More</a>
</div>


            </footer>


        </article>

    </div>
</main>

<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
                <article class="read-next-card" style="background-image: url(http://ruder.io/content/images/size/w600/2017/05/imageedit_8_8459453433.jpg)">
                    <header class="read-next-card-header">
                        <small class="read-next-card-header-sitetitle">— Sebastian Ruder —</small>
                        <h3 class="read-next-card-header-title"><a href="../tag/optimization/">optimization</a></h3>
                    </header>
                    <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path></svg>
</div>
                    <div class="read-next-card-content">
                        <ul>
                            <li><a href="../optimizing-gradient-descent/">An overview of gradient descent optimization algorithms</a></li>
                        </ul>
                    </div>
                    <footer class="read-next-card-footer">
                        <a href="../tag/optimization/">1 post →</a>
                    </footer>
                </article>



        </div>
    </div>
</aside>

<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://ruder.io">
            <span>Sebastian Ruder</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">Optimization for Deep Learning Highlights in 2017</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"></path>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Optimization%20for%20Deep%20Learning%20Highlights%20in%202017&amp;url=http://ruder.io/deep-learning-optimization-2017/" onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"></path></svg>
        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=http://ruder.io/deep-learning-optimization-2017/" onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"></path></svg>
        </a>
    </div>
    <progress id="reading-progress" class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = '/deep-learning-optimization-2017/';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'ghost-'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://sebastianruder.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://ruder.io">Sebastian Ruder</a> © 2019</section>
                <nav class="site-footer-nav">
                    <a href="http://ruder.io">Latest Posts</a>
                    
                    <a href="https://twitter.com/seb_ruder" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>


    <script>
        var images = document.querySelectorAll('.kg-gallery-image img');
        images.forEach(function (image) {
            var container = image.closest('.kg-gallery-image');
            var width = image.attributes.width.value;
            var height = image.attributes.height.value;
            var ratio = width / height;
            container.style.flex = ratio + ' 1 0%';
        })
    </script>


    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="../assets/built/jquery.fitvids.js?v=598e4ecdd9"></script>


    <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('#reading-progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();

});
</script>


    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-coy.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-python.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-60512592-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-60512592-1');
</script>

</body>
