<!DOCTYPE html>
<html>
  <head>
    <title>Optimization for Deep Learning Highlights in 2017</title>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">



<link rel="apple-touch-icon" sizes="57x57" href="../assets/img/apple-touch-icon-57x57.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="60x60" href="../assets/img/apple-touch-icon-60x60.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="72x72" href="../assets/img/apple-touch-icon-72x72.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="76x76" href="../assets/img/apple-touch-icon-76x76.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="114x114" href="../assets/img/apple-touch-icon-114x114.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="120x120" href="../assets/img/apple-touch-icon-120x120.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="144x144" href="../assets/img/apple-touch-icon-144x144.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="152x152" href="../assets/img/apple-touch-icon-152x152.png?v=wAAv6Wqe6l">
<link rel="apple-touch-icon" sizes="180x180" href="../assets/img/apple-touch-icon-180x180.png?v=wAAv6Wqe6l">
<link rel="icon" type="image/png" href="../assets/img/favicon-32x32.png?v=wAAv6Wqe6l" sizes="32x32">
<link rel="icon" type="image/png" href="../assets/img/favicon-194x194.png?v=wAAv6Wqe6l" sizes="194x194">
<link rel="icon" type="image/png" href="../assets/img/favicon-96x96.png?v=wAAv6Wqe6l" sizes="96x96">
<link rel="icon" type="image/png" href="../assets/img/android-chrome-192x192.png?v=wAAv6Wqe6l" sizes="192x192">
<link rel="icon" type="image/png" href="../assets/img/favicon-16x16.png?v=wAAv6Wqe6l" sizes="16x16">
<link rel="manifest" href="../assets/img/manifest.json?v=wAAv6Wqe6l">
<link rel="shortcut icon" href="../assets/img/favicon.ico?v=wAAv6Wqe6l">
<meta name="msapplication-TileColor" content="#e74c3c">
<meta name="msapplication-TileImage" content="/assets/img/mstile-144x144.png?v=wAAv6Wqe6l">
<meta name="msapplication-config" content="/assets/img/browserconfig.xml?v=wAAv6Wqe6l">
<meta name="theme-color" content="#e74c3c">
    <link rel="stylesheet" type="text/css" href="../assets/css/uno-zen.css?v=84e5a4b00d" />
    <link rel="canonical" href="http://ruder.io/deep-learning-optimization-2017/" />
    <meta name="referrer" content="origin" />
    
    <meta property="og:site_name" content="Sebastian Ruder" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Optimization for Deep Learning Highlights in 2017" />
    <meta property="og:description" content="An overview of the most exciting highlights and research directions in optimization for Deep Learning in 2017." />
    <meta property="og:url" content="u=http://ruder.io/deep-learning-optimization-2017/" />
    <meta property="og:image" content="u=http://ruder.io/content/images/2017/12/snapshot_ensembles.png" />
    <meta property="article:published_time" content="2017-12-03T15:36:00.000Z" />
    <meta property="article:modified_time" content="2017-12-03T20:17:39.631Z" />
    <meta property="article:tag" content="deep learning" />
    <meta property="article:tag" content="optimization" />
    
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Optimization for Deep Learning Highlights in 2017" />
    <meta name="twitter:description" content="An overview of the most exciting highlights and research directions in optimization for Deep Learning in 2017." />
    <meta name="twitter:url" content="u=http://ruder.io/deep-learning-optimization-2017/" />
    <meta name="twitter:image:src" content="u=http://ruder.io/content/images/2017/12/snapshot_ensembles.png" />
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "Sebastian Ruder",
    "author": {
        "@type": "Person",
        "name": "Sebastian Ruder",
        "url": "u=http://ruder.io/author/sebastian",
        "sameAs": null,
        "description": null
    },
    "headline": "Optimization for Deep Learning Highlights in 2017",
    "url": "u=http://ruder.io/deep-learning-optimization-2017/",
    "datePublished": "2017-12-03T15:36:00.000Z",
    "dateModified": "2017-12-03T20:17:39.631Z",
    "image": "u=http://ruder.io/content/images/2017/12/snapshot_ensembles.png",
    "keywords": "deep learning, optimization",
    "description": "An overview of the most exciting highlights and research directions in optimization for Deep Learning in 2017."
}
    </script>

    <meta name="generator" content="Ghost 0.7" />
    <link rel="alternate" type="application/rss+xml" title="Sebastian Ruder" href="http://ruder.io/rss/" />
    <script>
var open_button = '.nav-blog > a'
</script>
<script>
var profile_title = 'Sebastian Ruder';
</script>
<script>
var disqus_shortname = 'sebastianruder';
</script>
<script>
var profile_resume ='NLP PhD student';
</script>
<script>
var ga_id = 'UA-60512592-1';
</script>
  </head>
  <body class="post-template tag-deep-learning tag-optimization">
    <header id="menu-button" class="expanded">
      <a><i class="icon icon-list"></i></a>
    </header>
    <aside class="cover" style="background: url(../content/images/2017/05/imageedit_8_8459453433.jpg) center/cover no-repeat fixed">
  <div class="cover container">
    <div class="profile">
      <a id="avatar-link" title="link to homepage for Sebastian Ruder" href="http://ruder.io/#open">
        <img src="../content/images/2015/12/Seb_LinkedIn_Profile-.png" alt="Sebastian Ruder avatar" class="profile avatar rounded hvr-buzz-out" />
        <h1 id="profile-title">Sebastian Ruder</h1>
        <h3 id="profile-resume"></h3>
      </a>

      <hr class="divider long" />
      <p>I&#x27;m a PhD student in Natural Language Processing and a research scientist at AYLIEN. I blog about Machine Learning, Deep Learning, NLP, and startups.</p>
      <hr class="divider short" />
      <div class="navigation">
        <div class="profile contact">
          <nav class="navigation left">
  <ul class="links">
      <li class="nav-blog ">
        <a href="http://ruder.io/">Blog</a>
      </li>
      <li class="nav-about ">
        <a href="http://ruder.io/about/">About</a>
      </li>
      <li class="nav-papers ">
        <a href="http://ruder.io/publications/">Papers</a>
      </li>
      <li class="nav-news ">
        <a href="http://ruder.io/news">News</a>
      </li>
      <li class="nav-newsletter ">
        <a href="http://newsletter.ruder.io">Newsletter</a>
      </li>
      <li class="nav-faq ">
        <a href="http://ruder.io/faq">FAQ</a>
      </li>
  </ul>
</nav>

          
<nav class="navigation right">
  <ul class="social expanded">

  <!-- Twitter -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="http://twitter.com/seb_ruder" title="@seb_ruder on Twitter">
      <i class='icon icon-social-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  <!-- Linkedin -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://www.linkedin.com/in/sebastianruder" title="sebastianruder on LinkedIn">
      <i class='icon icon-social-linkedin'></i>
      <span class="label">Linkedin</span>
    </a>
  </li>

  <!-- Github -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="https://github.com/sebastianruder" title="sebastianruder on Github">
      <i class='icon icon-social-github'></i>
      <span class="label">Github</span>
    </a>
  </li>

  <!-- E-mail -->
  <li class="social item hvr-grow-rotate">
    <a rel="me" target="blank" href="mailto:sebastian@ruder.io" title="send me an email">
      <i class='icon icon-mail'></i>
      <span class="label">Email</span>
    </a>
  </li>

  <!-- RSS -->
  <li class="social item hvr-grow-rotate">
    <a href="../rss/index.html" title="Subscribe to RSS">
      <i class='icon icon-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  </ul>
</nav>
          <section class="icon icon-search" id="search-container">
  <hr class="divider short" />
  <form id="search-form" action="https://www.google.com/#q=site:u=http://ruder.io">
    <input type="text" name="search" placeholder="Deep Learning, NLP, ..." id="search-field" />
  </form>
</section>
        </div>
      </div>
    </div>
  </div>
</aside>
    <main>
      <section id="search-results"></section>
      <section class="content">
        

  <article class="post tag-deep-learning tag-optimization">
    <header>
      <div class="post meta">
        <time datetime="03 Dec 2017">03 Dec 2017</time>
        <span class="post tags">in <a href="../tag/deep-learning/index.html">deep learning</a> <a href="../tag/optimization/index.html">optimization</a></span>


        <span class="post reading-time"> ~ <span></span> read.</span>
      </div>
      <a alt="Tweet 'Optimization for Deep Learning Highlights in 2017'" href="https://twitter.com/intent/tweet?text=Optimization%20for%20Deep%20Learning%20Highlights%20in%202017%20%C2%BB&amp;hashtags=deep learning,optimization&amp;url=http://ruder.io/deep-learning-optimization-2017/">
        <img id="post-image" src="../content/images/2017/12/snapshot_ensembles.png" alt="Optimization for Deep Learning Highlights in 2017">
        <h1 class="icon-reverse icon-social-twitter-post" id="post-title">Optimization for Deep Learning Highlights in 2017</h1>
      </a>
    </header>

    <div id="post-content" class="post tag-deep-learning tag-optimization">
      <p>Table of contents:</p>

<ul>
<li><a href="index.html#improvingadam">Improving Adam</a>
<ul><li><a href="index.html#decouplingweightdecay">Decoupling weight decay</a></li>
<li><a href="index.html#fixingtheexponentialmovingaverage">Fixing the exponential moving average</a></li></ul></li>
<li><a href="index.html#tuningthelearningrate">Tuning the learning rate</a></li>
<li><a href="index.html#warmrestarts">Warm restarts</a>
<ul><li><a href="index.html#sgdwithrestarts">SGD with restarts</a></li>
<li><a href="index.html#snapshotensembles">Snapshot ensembles</a></li>
<li><a href="index.html#adamwithrestarts">Adam with restarts</a></li></ul></li>
<li><a href="index.html#learningtooptimize">Learning to optimize</a></li>
<li><a href="index.html#understandinggeneralization">Understanding generalization</a></li>
</ul>

<p>Deep Learning ultimately is about finding a minimum that generalizes well -- with bonus points for finding one fast and reliably. Our workhorse, stochastic gradient descent (SGD), is a 60-year old algorithm (Robbins and Monro, 1951) [<sup id="fnref:1"><a href="index.html#fn:1" rel="footnote">1</a></sup>], that is as essential to the current generation of Deep Learning algorithms as back-propagation.</p>

<p>Different optimization algorithms have been proposed in recent years, which use different equations to update a model's parameters. Adam (Kingma and Ba, 2015) [<sup id="fnref:18"><a href="index.html#fn:18" rel="footnote">18</a></sup>] was introduced in 2015 and is arguably today still the most commonly used one of these algorithms. This indicates that from the Machine Learning practitioner's perspective, best practices for optimization for Deep Learning have largely remained the same.</p>

<p>New ideas, however, have been developed over the course of this year, which may shape the way will optimize our models in the future. In this blog post, I will touch on the most exciting highlights and most promising directions in optimization for Deep Learning in my opinion. Note that this blog post assumes a familiarity with SGD and with adaptive learning rate methods such as Adam. To get up to speed, refer to <a href="http://ruder.io/optimizing-gradient-descent/index.html">this blog post</a> for an overview of existing gradient descent optimization algorithms.</p>

<h2 id="improvingadam">Improving Adam</h2>

<p>Despite the apparent supremacy of adaptive learning rate methods such as Adam, state-of-the-art results for many tasks in computer vision and NLP such as object recognition (Huang et al., 2017) [<sup id="fnref:17"><a href="index.html#fn:17" rel="footnote">17</a></sup>] or machine translation (Wu et al., 2016) [<sup id="fnref:3"><a href="index.html#fn:3" rel="footnote">3</a></sup>] have still been achieved by plain old SGD with momentum. Recent theory (Wilson et al., 2017) [<sup id="fnref:15"><a href="index.html#fn:15" rel="footnote">15</a></sup>] provides some justification for this, suggesting that adaptive learning rate methods converge to different (and less optimal) minima than SGD with momentum. It is empirically shown that the minima found by adaptive learning rate methods perform generally worse compared to those found by SGD with momentum on object recognition, character-level language modeling, and constituency parsing. This seems counter-intuitive given that Adam comes with nice convergence guarantees and that its adaptive learning rate should give it an edge over the regular SGD. However, Adam and other adaptive learning rate methods are not without their own flaws.</p>

<h3 id="decouplingweightdecay"> Decoupling weight decay</h3>

<p>One factor that partially accounts for Adam's poor generalization ability compared with SGD with momentum on some datasets is weight decay. Weight decay is most commonly used in image classification problems and decays the weights \(\theta_t\) after every parameter update by multiplying them by a decay rate \(w_t\) that is slightly less than \(1\):</p>

<p>\(\theta_{t+1} = w_t \: \theta_t \)</p>

<p>This prevents the weights from growing too large. As such, weight decay can also be understood as an \(\ell_2\) regularization term that depends on the weight decay rate \(w_t\) added to the loss:</p>

<p>\(\mathcal{L}_\text{reg} = \dfrac{w_t}{2} \|\theta_t \|^2_2 \)</p>

<p>Weight decay is commonly implemented in many neural network libraries either as the above regularization term or directly to modify the gradient. As the gradient is modified in both the momentum and Adam update equations (via multiplication with other decay terms), weight decay no longer equals \(\ell_2\) regularization. Loshchilov and Hutter (2017) [<sup id="fnref:19"><a href="index.html#fn:19" rel="footnote">19</a></sup>] thus propose to decouple weight decay from the gradient update by adding it after the parameter update as in the original definition. For SGD with momentum, this update then looks like the following:</p>

<p>\(
\begin{align}
\begin{split}
v_t &amp;= \gamma v_{t-1} + \eta g_t \\ <br />
\theta_{t+1} &amp;= \theta_t - v_t - \eta w_t \theta_t
\end{split}
\end{align}
\)</p>

<p>where \(\eta\) is the learning rate and the third term in the second equation is the decoupled weight decay. Similarly, for Adam we obtain:</p>

<p>\(
\begin{align}
\begin{split}
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\ <br />
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\ <br />
\hat{m}_t &amp;= \dfrac{m_t}{1 - \beta^t_1} \\
\hat{v}_t &amp;= \dfrac{v_t}{1 - \beta^t_2} \\
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t - \eta w_t \theta_t
\end{split}
\end{align}
\)</p>

<p>where \(m_t\) and \(\hat{m}_t\) and \(v_t\) and \(\hat{v}_t\) are the biased and bias-corrected estimates of the first and second moments respectively and \(\beta_1\) and \(\beta_2\) are their decay rates, with the same weight decay term added to it. The authors show that this substantially improves Adam’s generalization performance and allows it to compete with SGD with momentum on image classification datasets.</p>

<h3 id="fixingtheexponentialmovingaverage">Fixing the exponential moving average</h3>

<p>Several recent papers (Dozat and Manning, 2017; Laine and Aila, 2017) [<sup id="fnref:13"><a href="index.html#fn:13" rel="footnote">13</a></sup>,<sup id="fnref:16"><a href="index.html#fn:16" rel="footnote">16</a></sup>] empirically find that a lower \(\beta_2\) value, which controls the contribution of the exponential moving average of past squared gradients in Adam, e.g. \(0.99\) or \(0.9\) vs. the default \(0.999\) worked better in their respective applications, indicating that there might be an issue with the exponential moving average.</p>

<p>An <a href="https://openreview.net/forum?id=ryQu7f-RZ">ICLR 2018 submission</a> formalizes this issue and pinpoints the exponential moving average of past squared gradients as another reason for the poor generalization behaviour of adaptive learning rate methods. Updating the parameters via an exponential moving average of past squared gradients is at the heart of adaptive learning rate methods such as Adadelta, RMSprop, and Adam. The contribution of the exponential average is well-motivated: It should prevent the learning rates to become infinitesimally small as training progresses, the key flaw of the Adagrad algorithm. However, this short-term memory of the gradients becomes an obstacle in other scenarios.</p>

<p>In settings where Adam converges to a suboptimal solution, it has been observed that some minibatches provide large and informative gradients, but as these minibatches only occur rarely, exponential averaging diminishes their influence, which leads to poor convergence. The authors provide an example for a simple convex optimization problem where the same behaviour can be observed for Adam.</p>

<p>To fix this behaviour, the authors propose a new algorithm, AMSGrad that uses the maximum of past squared gradients rather than the exponential average to update the parameters. The full AMSGrad update without bias-corrected estimates can be seen below:</p>

<p>\(
\begin{align}
\begin{split}
m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\ <br />
v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2\\ <br />
\hat{v}_t &amp;= \text{max}(\hat{v}_{t-1}, v_t) \\
\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} m_t
\end{split}
\end{align}
\)</p>

<p>The authors observe improved performance compared to Adam on small datasets and on CIFAR-10.</p>

<h2 id="tuningthelearningrate">Tuning the learning rate</h2>

<p>In many cases, it is not our models that require improvement and tuning, but our hyperparameters. Recent examples for language modelling demonstrate that tuning LSTM parameters (Melis et al., 2017) [<sup id="fnref:20"><a href="index.html#fn:20" rel="footnote">20</a></sup>] and regularization parameters (Merity et al., 2017) [<sup id="fnref:21"><a href="index.html#fn:21" rel="footnote">21</a></sup>] can yield state-of-the-art results compared to more complex models.</p>

<p>An important hyperparameter for optimization in Deep Learning is the learning rate \(\eta\). In fact, SGD has been shown to require a learning rate annealing schedule to converge to a good minimum in the first place. It is often thought that adaptive learning rate methods such as Adam are more robust to different learning rates, as they update the learning rate themselves. Even for these methods, however, there can be a large difference between a good and the optimal learning rate (psst... it's <a href="https://twitter.com/karpathy/status/801621764144971776">\(3e-4\)</a>). </p>

<p>Zhang et al. (2017) [<sup id="fnref:2"><a href="index.html#fn:2" rel="footnote">2</a></sup>] show that SGD with a tuned learning rate annealing schedule and momentum parameter is not only competitive with Adam, but also converges faster. On the other hand, while we might think that the adaptivity of Adam's learning rates might mimic learning rate annealing, an explicit annealing schedule can still be beneficial: If we add SGD-style learning rate annealing to Adam, it converges faster and outperforms SGD on Machine Translation (Denkowski and Neubig, 2017) [<sup id="fnref:4"><a href="index.html#fn:4" rel="footnote">4</a></sup>].</p>

<p>In fact, learning rate annealing schedule engineering seems to be the new feature engineering as we can often find highly-tuned learning rate annealing schedules that improve the final convergence behaviour of our model. An interesting example of this is Vaswani et al. (2017) [<sup id="fnref:14"><a href="index.html#fn:14" rel="footnote">14</a></sup>]. While it is usual to see a model's hyperparameters being subjected to large-scale hyperparameter optimization, it is interesting to see a learning rate annealing schedule as the focus of the same attention to detail: The authors use Adam with \(\beta_1=0.9\), a non-default \(\beta_2=0.98\), \(\epsilon = 10^{-9}\), and arguably one of the most elaborate annealing schedules for the learning rate \(\eta\):</p>

<p>\(\eta  = d_\text{model}^{-0.5} \cdot \min(step\text{_}num^{-0.5}, step\text{_}num \cdot warmup\text{_}steps^{-1.5}) \)</p>

<p>where \(d_\text{model}\) is the number of parameters of the model and \(warmup\text{_}steps = 4000\). </p>

<p>Another recent paper by Smith et al. (2017) [<sup id="fnref:5"><a href="index.html#fn:5" rel="footnote">5</a></sup>] demonstrates an interesting connection between the learning rate and the batch size, two hyperparameters that are typically thought to be independent of each other: They show that decaying the learning rate is equivalent to increasing the batch size, while the latter allows for increased parallelism. Conversely, we can reduce the number of model updates and thus speed up training by increasing the learning rate and scaling the batch size. This has ramifications for large-scale Deep Learning, which can now repurpose existing training schedules with no hyperparameter tuning.</p>

<h2 id="warmrestarts">Warm restarts</h2>

<h3 id="sgdwithrestarts"> SGD with restarts</h3>

<p>Another effective recent development is SGDR (Loshchilov and Hutter, 2017) [<sup id="fnref:6"><a href="index.html#fn:6" rel="footnote">6</a></sup>], an SGD alternative that uses warm restarts instead of learning rate annealing. In each restart, the learning rate is initialized to some value and is scheduled to decrease. Importantly, the restart is warm as the optimization does not start from scratch but from the parameters to which the model converged during the last step. The key factor is that the learning rate is decreased with an aggressive cosine annealing schedule, which rapidly lowers the learning rate and looks like the following:</p>

<p>\(\eta_t = \eta_{min}^i + \dfrac{1}{2}(\eta_{max}^i - \eta_{min}^i)(1 + \text{cos}(\dfrac{T_{cur}}{T_i}\pi)) \)</p>

<p>where \(\eta_{min}^i\) and \(\eta_{max}^i\) are ranges for the learning rate during the \(i\)-th run, \(T_{cur}\) indicates how many epochs passed since the last restart, and \(T_i\) specifies the epoch of the next restart. The warm restart schedules for \(T_i=50\), \(T_i=100\), and \(T_i=200\) compared with regular learning rate annealing are shown in Figure 1.</p>

<figure>  
      <img src="../content/images/2017/11/warm_restarts.png" style="width: 100%; height: 100%" title="Learning rate schedules with warm restarts">
<figcaption>Figure 1: Learning rate schedules with warm restarts (Loshchilov and Hutter,  
 2017)</figcaption>
</figure>

<p>The high initial learning rate after a restart is used to essentially catapult the parameters out of the minimum to which they previously converged and to a different area of the loss surface. The aggressive annealing then enables the model to rapidly converge to a new and better solution. The authors empirically find that SGD with warm restarts requires 2 to 4 times fewer epochs than learning rate annealing and achieves comparable or better performance.</p>

<p>Learning rate annealing with warm restarts is also known as cyclical learning rates and has been originally proposed by Smith (2017) [<sup id="fnref:22"><a href="index.html#fn:22" rel="footnote">22</a></sup>]. Two more articles by students of fast.ai (which has recently started to teach this method) that discuss warm restarts and cyclical learning rates can be found <a href="https://medium.com/@bushaev/improving-the-way-we-work-with-learning-rate-5e99554f163b">here</a> and <a href="http://teleported.in/posts/cyclic-learning-rate/">here</a>.</p>

<h3 id="snapshotensembles"> Snapshot ensembles</h3>

<p>Snapshot ensembles (Huang et al., 2017) [<sup id="fnref:7"><a href="index.html#fn:7" rel="footnote">7</a></sup>] are a clever, recent technique that uses warm restarts to assemble an ensemble essentially for free when training a single model. The method trains a single model until convergence with the cosine annealing schedule that we have seen above. It then saves the model parameters, performs a warm restart, and then repeats these steps \(M\) times. In the end, all saved model snapshots are ensembled. The common SGD optimization behaviour on an error surface compared to the behaviour of snapshot ensembling can be seen in Figure 2.</p>

<figure>  
      <img src="../content/images/2017/11/snapshot_ensembles.png" style="width: 100%; height: 100%" title="Learning rate schedules with warm restarts">
<figcaption>Figure 2: SGD vs. snapshot ensemble (Huang et al., 2017)</figcaption>  
</figure>

<p>The success of ensembling in general relies on the diversity of the individual models in the ensemble. Snapshot ensembling thus relies on the cosine annealing schedule's ability to enable the model to converge to a different local optimum after every restart. The authors demonstrate that this holds in practice, achieving state-of-the-art results on CIFAR-10, CIFAR-100, and SVHN.</p>

<h3 id="adamwithrestarts">Adam with restarts</h3>

<p>Warm restarts did not work originally with Adam due to its dysfunctional weight decay, which we have seen before. After fixing weight decay, Loshchilov and Hutter (2017) similarly extend Adam to work with warm restarts. They set \(\eta_{min}^i=0\) and \(\eta_{max}^i=1\), which yields:</p>

<p>\(\eta_t = 0.5 + 0.5 \: \text{cos}(\dfrac{T_{cur}}{T_i}\pi))\)</p>

<p>They recommend to start with an initially small \(T_i\) (between \(1%\) and \(10%\) of the total number of epochs) and multiply it by a factor of \(T_{mult}\) (e.g. \(T_{mult}=2\)) at every restart.</p>

<h2 id="learningtooptimize">Learning to optimize</h2>

<p>One of the most interesting papers of last year (and <a href="https://www.reddit.com/r/MachineLearning/comments/5n53k7/d_results_from_the_best_paper_awards/">reddit's "Best paper name of 2016" winner</a>) was a paper by Andrychowicz et al. (2016) [<sup id="fnref:23"><a href="index.html#fn:23" rel="footnote">23</a></sup>] where they train an LSTM optimizer to provide the updates to the main model during training. Unfortunately, learning a separate LSTM optimizer or even using a pre-trained LSTM optimizer for optimization greatly increases the complexity of model training.</p>

<p>Another very influential learning-to-learn paper from this year uses an LSTM to generate model architectures in a domain-specific language (Zoph and Quoc, 2017) [<sup id="fnref:24"><a href="index.html#fn:24" rel="footnote">24</a></sup>]. While the search process requires vast amounts of resources, the discovered architectures can be used as-is to replace their existing counterparts. This search process has proved effective and found architectures that achieve state-of-the-art results on language modeling and results competitive with the state-of-the-art on CIFAR-10.</p>

<p>The same search principle can be applied to any other domain where key processes have been previously defined by hand. One such domain are optimization algorithms for Deep Learning. As we have seen before, optimization algorithms are more similar than they seem: All of them use a combination of an exponential moving average of past gradients (as in momentum) and of an exponential moving average of past squared gradients (as in Adadelta, RMSprop, and Adam) (Ruder, 2016) [<sup id="fnref:25"><a href="index.html#fn:25" rel="footnote">25</a></sup>].</p>

<p>Bello et al. (2017) [<sup id="fnref:8"><a href="index.html#fn:8" rel="footnote">8</a></sup>] define a domain-specific language that consists of primitives useful for optimization such as these exponential moving averages. They then sample an update rule from the space of possible update rules, use this update rule to train a model, and update the RNN controller based on the performance of the trained model on the test set. The full procedure can be seen in Figure 3. </p>

<figure>  
      <img src="../content/images/2017/11/neural_optimizer_search.png" style="width: 100%; height: 100%" title="Neural Optimizer Search">
<figcaption>Figure 3: Neural Optimizer Search (Bello et al., 2017)</figcaption>  
</figure>

<p>In particular, they discover two update equations, PowerSign and AddSign. The update equation for PowerSign is the following:</p>

<p>\( \theta_{t+1} = \theta_{t} - \alpha^{f(t)*
\text{sign}(g_t)*\text{sign}(m_t)}*g_t \)</p>

<p>where \(\alpha\) is a hyperparameter that is often set to \(e\) or \(2\), \(f(t)\) is either \(1\) or a decay function that performs linear, cyclical or decay with restarts based on time step \(t\), and \(m_t\) is the moving average of past gradients. The common configuration uses \(\alpha=e\) and no decay.  We can observe that the update scales the gradient by \(\alpha^{f(t)}\) or \(1/\alpha^{f(t)}\) depending on whether the direction of the gradient and its moving average agree. This indicates that this momentum-like agreement between past gradients and the current one is a key piece of information for optimizing Deep Learning models.</p>

<p>AddSign in turn is defined as follows:</p>

<p>\( \theta_{t+1} = \theta_{t} - \alpha + f(t) * \text{sign}(g_t) * \text{sign}(m_t)) * g_t\)</p>

<p>with \(\alpha\) often set to \(1\) or \(2\). Similar to the above, this time the update scales \(\alpha + f(t)\) or \(\alpha - f(t)\) again depending on the agreement of the direction of the gradients. The authors show that PowerSign and AddSign outperform Adam, RMSprop, and SGD with momentum on CIFAR-10 and transfer well to other tasks such as ImageNet classification and machine translation.</p>

<h2 id="understandinggeneralization">Understanding generalization</h2>

<p>Optimization is closely tied to generalization as the minimum to which a model converges defines how well the model generalizes. Advances in optimization are thus closely correlated with theoretical advances in understanding the generalization behaviour of such minima and more generally of gaining a deeper understanding of generalization in Deep Learning.</p>

<p>However, our understanding of the generalization behaviour of deep neural networks is still very shallow. Recent work showed that the number of possible local minima grows exponentially with the number of parameters (Kawaguchi, 2016) [<sup id="fnref:9"><a href="index.html#fn:9" rel="footnote">9</a></sup>]. Given the huge number of parameters of current Deep Learning architectures, it still seems almost magical that such models converge to solutions that generalize well, in particular given that they can completely memorize random inputs (Zhang et al., 2017) [<sup id="fnref:10"><a href="index.html#fn:10" rel="footnote">10</a></sup>].</p>

<p>Keskar et al. (2017) [<sup id="fnref:11"><a href="index.html#fn:11" rel="footnote">11</a></sup>] identify the sharpness of a minimum as a source for poor generalization: In particular, they show that sharp minima found by batch gradient descent have high generalization error. This makes intuitive sense, as we generally would like our functions to be smooth and a sharp minima indicates a high irregularity in the corresponding error surface. However, more recent work suggests that sharpness may not be such a good indicator after all by showing that local minima that generalize well can be made arbitrarily sharp (Dinh et al., 2017) [<sup id="fnref:12"><a href="index.html#fn:12" rel="footnote">12</a></sup>]. A <a href="https://www.quora.com/Why-is-the-paper-%E2%80%9CUnderstanding-Deep-Learning-Requires-Rethinking-Generalization%E2%80%9D-important/answer/Eric-Jang?srid=dWc3">Quora answer by Eric Jang</a> also discusses these articles.</p>

<p>An <a href="https://openreview.net/forum?id=r1iuQjxCZ">ICLR 2018 submission</a> demonstrates through a series of ablation analyses that a model's reliance on single directions in activation space, i.e. the activation of single units or feature maps is a good predictor of its generalization performance. They show that this holds across models trained on different datasets and for different degrees of label corruption. They find that dropout does not help to resolve this, while batch normalization discourages single direction reliance.</p>

<p>While these findings indicate that there is still much we do not know in terms of Optimization for Deep Learning, it is important to remember that convergence guarantees and a large body of work exists for convex optimization and that existing ideas and insights can also be applied to non-convex optimization to some extent. The large-scale optimization tutorial at NIPS 2016 provides an excellent overview of more theoretical work in this area (see the <a href="https://www.di.ens.fr/~fbach/fbach_tutorial_vr_nips_2016.pdf">slides part 1</a>, <a href="http://suvrit.de/talks/vr_nips16_sra.pdf">part 2</a>, and the <a href="https://channel9.msdn.com/Events/Neural-Information-Processing-Systems-Conference/Neural-Information-Processing-Systems-Conference-NIPS-2016/Large-Scale-Optimization-Beyond-Stochastic-Gradient-Descent-and-Convexity">video</a>).</p>

<h2 id="conclusion"> Conclusion</h2>

<p>I hope that I was able to provide an impression of some of the compelling developments in optimization for Deep Learning over the past year. I've undoubtedly failed to mention many other approaches that are equally important and noteworthy. Please let me know in the comments below what I missed, where I made a mistake or misrepresented a method, or which aspect of optimization for Deep Learning you find particularly exciting or underexplored.</p>

<h1 id="references">References</h1>

<div class="footnotes"><ol><li class="footnote" id="fn:1"><p>Robbins, H., &amp; Monro, S. (1951). A stochastic approximation method. The annals of mathematical statistics, 400-407. <a href="index.html#fnref:1" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:2"><p>Zhang, J., Mitliagkas, I., &amp; Ré, C. (2017). YellowFin and the Art of Momentum Tuning. In arXiv preprint arXiv:1706.03471. <a href="index.html#fnref:2" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:3"><p>Wu, Y., Schuster, M., Chen, Z., Le, Q. V, Norouzi, M., Macherey, W., … Dean, J. (2016). Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation. arXiv Preprint arXiv:1609.08144. <a href="index.html#fnref:3" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:4"><p>Denkowski, M., &amp; Neubig, G. (2017). Stronger Baselines for Trustable Results in Neural Machine Translation. In Workshop on Neural Machine Translation (WNMT). Retrieved from <a href="https://arxiv.org/abs/1706.09733">https://arxiv.org/abs/1706.09733</a> <a href="index.html#fnref:4" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:5"><p>Smith, S. L., Kindermans, P.-J., &amp; Le, Q. V. (2017). Don’t Decay the Learning Rate, Increase the Batch Size. In arXiv preprint arXiv:1711.00489. Retrieved from <a href="http://arxiv.org/abs/1711.00489">http://arxiv.org/abs/1711.00489</a> <a href="index.html#fnref:5" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:6"><p>Loshchilov, I., &amp; Hutter, F. (2017). SGDR: Stochastic Gradient Descent with Warm Restarts. In Proceedings of ICLR 2017. <a href="https://doi.org/10.1002/fut">https://doi.org/10.1002/fut</a> <a href="index.html#fnref:6" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:7"><p>Huang, G., Li, Y., Pleiss, G., Liu, Z., Hopcroft, J. E., &amp; Weinberger, K. Q. (2017). Snapshot Ensembles: Train 1, get M for free. In Proceedings of ICLR 2017. <a href="index.html#fnref:7" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:8"><p>Bello, I., Zoph, B., Vasudevan, V., &amp; Le, Q. V. (2017). Neural Optimizer Search with Reinforcement Learning. In Proceedings of the 34th International Conference on Machine Learning. <a href="index.html#fnref:8" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:9"><p>Kawaguchi, K. (2016). Deep Learning without Poor Local Minima. In Advances in Neural Information Processing Systems 29 (NIPS 2016). Retrieved from <a href="http://arxiv.org/abs/1605.07110">http://arxiv.org/abs/1605.07110</a> <a href="index.html#fnref:9" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:10"><p>Zhang, C., Bengio, S., Hardt, M., Recht, B., &amp; Vinyals, O. (2017). Understanding deep learning requires rethinking generalization. In Proceedings of ICLR 2017. <a href="index.html#fnref:10" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:11"><p>Keskar, N. S., Mudigere, D., Nocedal, J., Smelyanskiy, M., &amp; Tang, P. T. P. (2017). On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima. In Proceedings of ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1609.04836">http://arxiv.org/abs/1609.04836</a> <a href="index.html#fnref:11" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:12"><p>Dinh, L., Pascanu, R., Bengio, S., &amp; Bengio, Y. (2017). Sharp Minima Can Generalize For Deep Nets. In Proceedings of the 34th International Conference on Machine Learning. <a href="index.html#fnref:12" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:13"><p>Dozat, T., &amp; Manning, C. D. (2017). Deep Biaffine Attention for Neural Dependency Parsing. In ICLR 2017. Retrieved from <a href="http://arxiv.org/abs/1611.01734">http://arxiv.org/abs/1611.01734</a> <a href="index.html#fnref:13" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:14"><p>Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., … Polosukhin, I. (2017). Attention Is All You Need. In Advances in Neural Information Processing Systems. <a href="index.html#fnref:14" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:15"><p>Wilson, A. C., Roelofs, R., Stern, M., Srebro, N., &amp; Recht, B. (2017). The Marginal Value of Adaptive Gradient Methods in Machine Learning. arXiv Preprint arXiv:1705.08292. Retrieved from <a href="http://arxiv.org/abs/1705.08292">http://arxiv.org/abs/1705.08292</a> <a href="index.html#fnref:15" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:16"><p>Laine, S., &amp; Aila, T. (2017). Temporal Ensembling for Semi-Supervised Learning. In Proceedings of ICLR 2017. <a href="index.html#fnref:16" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:17"><p>Huang, G., Liu, Z., Weinberger, K. Q., &amp; van der Maaten, L. (2017). Densely Connected Convolutional Networks. In Proceedings of CVPR 2017. <a href="index.html#fnref:17" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:18"><p>Kingma, D. P., &amp; Ba, J. L. (2015). Adam: a Method for Stochastic Optimization. International Conference on Learning Representations. <a href="index.html#fnref:18" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:19"><p>Loshchilov, I., &amp; Hutter, F. (2017). Fixing Weight Decay Regularization in Adam. arXiv Preprint arXi1711.05101. Retrieved from <a href="http://arxiv.org/abs/1711.05101">http://arxiv.org/abs/1711.05101</a> <a href="index.html#fnref:19" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:20"><p>Melis, G., Dyer, C., &amp; Blunsom, P. (2017). On the State of the Art of Evaluation in Neural Language Models. In arXiv preprint arXiv:1707.05589. <a href="index.html#fnref:20" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:21"><p>Merity, S., Shirish Keskar, N., &amp; Socher, R. (2017). Regularizing and Optimizing LSTM Language Models. arXiv Preprint arXiv:1708.02182. Retrieved from <a href="https://arxiv.org/pdf/1708.02182.pdf">https://arxiv.org/pdf/1708.02182.pdf</a> <a href="index.html#fnref:21" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:22"><p>Smith, Leslie N. "Cyclical learning rates for training neural networks." In Applications of Computer Vision (WACV), 2017 IEEE Winter Conference on, pp. 464-472. IEEE, 2017. <a href="index.html#fnref:22" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:23"><p>Andrychowicz, M., Denil, M., Gomez, S., Hoffman, M. W., Pfau, D., Schaul, T., &amp; de Freitas, N. (2016). Learning to learn by gradient descent by gradient descent. In Advances in Neural Information Processing Systems. Retrieved from <a href="http://arxiv.org/abs/1606.04474">http://arxiv.org/abs/1606.04474</a> <a href="index.html#fnref:23" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:24"><p>Zoph, B., &amp; Le, Q. V. (2017). Neural Architecture Search with Reinforcement Learning. In ICLR 2017. <a href="index.html#fnref:24" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:25"><p>Ruder, S. (2016). An overview of gradient descent optimization algorithms. arXiv Preprint arXiv:1609.04747. <a href="index.html#fnref:25" title="return to article">↩</a></p></li></ol></div>
    </div>

    <div class="post related">
        <a rel="prev" id="prev-btn" class="btn small square" href="../word-embeddings-2017/index.html">← Word embeddings in 2017: Trends and future directions</a>

    </div>

    <footer class="post comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + window.disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</footer>

  </article>


<script type="text/javascript"  
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>  

        <footer>
  <span class="copyright">
    &copy; 2017. All rights reserved. Built with <a href="https://ghost.org/" target="_blank">Ghost</a> and <a href="https://github.com/Kikobeats/uno-zen" target="_blank">Uno Zen</a> theme.
  </span>
</footer>
      </section>
    </main>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script>jQuery = Zepto</script>
    <script src="../assets/js/uno-zen.js?v=84e5a4b00d" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
  if (window.ga_id) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', window.ga_id, 'auto');
    ga('require', 'linkid', 'linkid.js');
    ga('send', 'pageview');
  }
</script>
  </body>
</html>
